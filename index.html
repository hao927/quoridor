<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Quoridor 3D - Ultimate</title>
    
    <!-- Firebase Libraries -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', 'Helvetica Neue', sans-serif;
            background-color: #111;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            color: white;
        }

        /* --- Screens & Overlays --- */
        .screen-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s;
        }

        #start-screen { z-index: 2001; background: url('https://images.unsplash.com/photo-1611195974226-a6a9be9dd763?q=80&w=1925&auto=format&fit=crop') center/cover no-repeat; }
        #start-screen::before { content:''; position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:-1; }
        
        #settings-menu { display: none; background: rgba(0, 0, 0, 0.9); backdrop-filter: blur(8px); z-index: 2002; }
        
        /* Lobby UI */
        #lobby-screen { display: none; background: rgba(10,10,10,0.95); z-index: 2002; }
        .lobby-container { 
            width: 90%; max-width: 500px; height: 75%; 
            background: rgba(30,30,30,0.6); border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.1);
            display: flex; flex-direction: column; padding: 25px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
        }
        .room-list { 
            flex: 1; overflow-y: auto; margin: 15px 0;
            background: rgba(0,0,0,0.2); border-radius: 8px; padding: 5px;
            border: 1px solid rgba(255,255,255,0.05);
        }
        .room-item {
            display: flex; justify-content: space-between; align-items: center;
            background: rgba(255,255,255,0.05); margin-bottom: 8px; padding: 15px; 
            border-radius: 8px; cursor: pointer; transition: 0.2s;
            border-left: 4px solid #448aff;
        }
        .room-item:hover { background: rgba(255,255,255,0.1); transform: translateX(5px); }
        .room-item.private { border-left-color: #ff5252; }
        
        /* Training HUD */
        #training-hud {
            position: absolute; top: 80px; right: 20px; width: 250px;
            background: rgba(0, 0, 0, 0.8); border: 1px solid #00e676;
            border-radius: 10px; padding: 15px; color: #00e676;
            font-family: 'Consolas', monospace; font-size: 12px;
            display: none; z-index: 150; pointer-events: none;
        }
        .hud-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .hud-val { font-weight: bold; color: white; }

        /* Victory Screen */
        #victory-screen { 
            display: none; z-index: 2003; background: rgba(0, 0, 0, 0.95); cursor: pointer;
        }
        .victory-title {
            font-size: 60px; font-weight: bold; margin-bottom: 20px;
            text-transform: uppercase; letter-spacing: 5px;
            background: linear-gradient(to right, #fff, #aaa); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            animation: popIn 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .victory-subtitle { font-size: 20px; color: #aaa; animation: fadeIn 2s ease-in; }
        
        @keyframes popIn { 0% { transform: scale(0); opacity: 0; } 80% { transform: scale(1.1); opacity: 1; } 100% { transform: scale(1); } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        h1 { font-size: 60px; margin-bottom: 40px; text-shadow: 0 0 30px rgba(255,255,255,0.3); text-align: center; letter-spacing: 2px; }
        h2 { font-size: 24px; color: #ddd; margin-bottom: 20px; margin-top: 0;}

        /* Buttons */
        .menu-btn {
            background: linear-gradient(135deg, #448aff, #1976d2);
            border: none; color: white; padding: 20px 40px; margin: 10px;
            font-size: 20px; border-radius: 12px; cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3); transition: 0.2s;
            width: 320px; text-align: center; font-weight: bold;
        }
        .menu-btn:active { transform: scale(0.95); filter: brightness(0.8); }
        .menu-btn.ai { background: linear-gradient(135deg, #7b1fa2, #4a148c); }
        .menu-btn.train { background: linear-gradient(135deg, #00c853, #00695c); box-shadow: 0 0 20px rgba(0, 230, 118, 0.4); }
        .menu-btn.online { background: linear-gradient(135deg, #f57c00, #e65100); }
        .menu-btn.secondary { background: #444; border: 1px solid #666; font-size: 18px; padding: 15px 30px; width: 250px; }
        .menu-btn.small { width: auto; padding: 10px 20px; font-size: 16px; margin: 5px; }
        .menu-btn.cancel { background: #d32f2f; width: 100%; margin: 10px 0 0 0; }

        /* Modals */
        .modal { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.85); display: none; 
            justify-content: center; align-items: center; z-index: 3000;
        }
        .modal-content { 
            background: #222; padding: 30px; border-radius: 16px; width: 320px; 
            box-shadow: 0 10px 40px rgba(0,0,0,0.8); border: 1px solid #444;
            text-align: center;
        }
        input[type="text"], input[type="number"] {
            width: 100%; padding: 12px; margin: 10px 0;
            background: #111; border: 1px solid #555; color: white; 
            border-radius: 8px; font-size: 16px; text-align: center; box-sizing: border-box;
        }

        /* --- UI Overlay --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
        }

        #settings-btn {
            position: absolute; top: 20px; left: 20px; width: 50px; height: 50px;
            background: rgba(50, 50, 50, 0.8); border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.2); color: white; font-size: 24px;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; pointer-events: auto; z-index: 150;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        #settings-btn:active { transform: scale(0.9); }

        #divider {
            position: absolute; left: 50%; top: 0; bottom: 0; width: 2px;
            background: rgba(255,255,255,0.1); z-index: 100; transition: 0.3s;
        }

        #status-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(20, 20, 20, 0.85); backdrop-filter: blur(10px);
            padding: 10px 40px; border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #eee; font-size: 18px; font-weight: bold;
            pointer-events: auto; z-index: 101;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); white-space: nowrap; transition: 0.3s;
        }
        
        .wall-dock-container {
            position: absolute; width: 35%; height: 80px;
            background: rgba(0,0,0,0.5); border-radius: 16px;
            display: flex; align-items: center; justify-content: center; gap: 8px; padding: 0 15px;
            pointer-events: auto; transition: 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 1px solid transparent; z-index: 102;
        }
        
        /* Computer Mode Positions */
        .mode-split #dock-p1 { bottom: 20px; left: 2%; }
        .mode-split #dock-p2 { bottom: 20px; right: 2%; }

        /* Tablet/Single Mode Positions */
        .mode-single #dock-p1 { bottom: 20px; left: 50%; transform: translateX(-50%); width: 50%; }
        /* For Online/Single P2, we reuse p1 dock visually or hide logic */

        .wall-dock-container.active {
            background: rgba(255,255,255,0.1); border-color: rgba(255,255,255,0.3);
            box-shadow: 0 0 15px rgba(255,255,255,0.1);
        }
        .wall-dock-container.inactive { opacity: 0.3; pointer-events: none; filter: grayscale(1); }

        .wall-item {
            width: 14px; height: 50px; background: #d4a373; border-radius: 4px;
            cursor: grab; box-shadow: 0 2px 5px rgba(0,0,0,0.5); position: relative;
        }
        .wall-item.dragging { opacity: 0; }
        
        .dock-label {
            position: absolute; top: -25px; font-size: 14px; color: #aaa;
            font-weight: bold; text-shadow: 0 1px 2px black; width: 100%; text-align: center;
        }

        /* Controls Center */
        #controls-center {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; pointer-events: auto; z-index: 200; transition: 0.3s;
        }
        .mode-single #controls-center { bottom: 50%; flex-direction: column; left: auto; right: 10px; transform: translateY(50%); }

        .action-btn {
            background: #444; color: white; border: 1px solid rgba(255,255,255,0.3);
            padding: 12px 24px; border-radius: 12px; font-size: 16px; cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3); -webkit-tap-highlight-color: transparent;
        }
        .action-btn:active { transform: scale(0.95); }
        #undo-btn { background: #d32f2f; }
        #speed-btn { background: #009688; display: none; }

        #ai-thinking {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(123, 31, 162, 0.9); color: white;
            padding: 8px 16px; border-radius: 20px;
            display: none; z-index: 102;
            box-shadow: 0 0 15px rgba(123, 31, 162, 0.6);
        }

        .view-label {
            position: absolute; top: 20px; font-size: 14px; color: rgba(255,255,255,0.4);
            font-weight: bold; text-transform: uppercase;
            background: rgba(0,0,0,0.3); padding: 4px 8px; border-radius: 4px;
        }
        #label-p1 { left: 80px; } 
        #label-p2 { right: 20px; }

        #toast { 
            position: absolute; bottom: 60%; left: 50%; transform: translateX(-50%); 
            background: rgba(0,0,0,0.8); color: white; padding: 15px 30px; border-radius: 8px; 
            z-index: 3000; opacity: 0; transition: opacity 0.3s; pointer-events: none; font-size: 18px;
            border: 1px solid #444;
        }

        /* Opponent Info (Online/Single) */
        #dock-opp {
            position: absolute; top: 80px; left: 20px;
            background: rgba(0,0,0,0.6); padding: 10px 20px; border-radius: 20px;
            display: none; align-items: center; gap: 10px; pointer-events: auto;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .mode-single #dock-opp { display: flex; }
    </style>
</head>
<body class="mode-split">

    <!-- Start Screen -->
    <div id="start-screen" class="screen-overlay">
        <h1>Quoridor 3D</h1>
        <button class="menu-btn" onclick="startGame('pvp')">üë• Èõô‰∫∫Â∞çÊà∞ (PvP)</button>
        <button class="menu-btn ai" onclick="startGame('pve')">ü§ñ ÊåëÊà∞ AI (PvE)</button>
        <button class="menu-btn online" onclick="openLobby()">üåê Á∑ö‰∏äÂ∞çÊà∞ (Online)</button>
        <button class="menu-btn train" onclick="startGame('train')">üß¨ ÈÄ≤ÂåñË®ìÁ∑¥Ê®°Âºè</button>
    </div>

    <!-- Lobby & Modals (For Online) -->
    <div id="lobby-screen" class="screen-overlay">
        <h2 style="margin-bottom:10px;">Á∑ö‰∏äÈÅäÊà≤Â§ßÂª≥</h2>
        <div class="lobby-container">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                <span id="player-id-display" style="color:#00e676; font-size:14px; font-family:monospace;">ÈÄ£Á∑ö‰∏≠...</span>
                <button onclick="showCreateRoom()" class="menu-btn small" style="background:#00c853;">+ Âª∫Á´ãÊàøÈñì</button>
            </div>
            <div class="room-list" id="room-list"><div style="text-align:center; color:#888; padding:30px;">ËºâÂÖ•ÊàøÈñìÂàóË°®...</div></div>
            <button class="menu-btn cancel" onclick="closeLobby()">ËøîÂõû‰∏ªÈÅ∏ÂñÆ</button>
        </div>
    </div>

    <div id="create-modal" class="modal">
        <div class="modal-content">
            <h3>Âª∫Á´ãÊñ∞ÊàøÈñì</h3>
            <input type="text" id="new-room-name" placeholder="ÊàøÈñìÂêçÁ®±" maxlength="10">
            <div style="margin:15px 0; display:flex; align-items:center; justify-content:center; gap:10px;">
                <input type="checkbox" id="is-private" onchange="togglePasswordInput()" style="transform:scale(1.2);">
                <label for="is-private">Ë®≠ÂÆöÂØÜÁ¢º</label>
            </div>
            <input type="number" id="room-password" placeholder="6 ‰ΩçÊï∏ÂØÜÁ¢º" style="display:none;" oninput="if(this.value.length>6) this.value=this.value.slice(0,6);">
            <button class="menu-btn small online" onclick="createRoom()">Âª∫Á´ã</button>
            <button class="menu-btn small secondary" onclick="document.getElementById('create-modal').style.display='none'">ÂèñÊ∂à</button>
        </div>
    </div>

    <div id="password-modal" class="modal">
        <div class="modal-content">
            <h3>üîí Ëº∏ÂÖ•ÊàøÈñìÂØÜÁ¢º</h3>
            <p id="join-room-name" style="color:#00e676; margin:5px 0; font-size:14px;"></p>
            <input type="number" id="join-password" placeholder="6 ‰ΩçÊï∏ÂØÜÁ¢º">
            <button class="menu-btn small online" onclick="submitPassword()">Âä†ÂÖ•</button>
            <button class="menu-btn small secondary" onclick="closePasswordModal()">ÂèñÊ∂à</button>
        </div>
    </div>

    <div id="waiting-modal" class="modal">
        <div class="modal-content">
            <h3>Á≠âÂæÖÂ∞çÊâãÂä†ÂÖ•...</h3>
            <div style="font-size:40px; margin:20px 0; animation: spin 2s infinite linear;">‚è≥</div>
            <p>ÊàøËôü: <span id="wait-room-id" style="color:#00e676; font-family:monospace; font-weight:bold;"></span></p>
            <button class="menu-btn cancel" onclick="leaveRoom()">ÂèñÊ∂à / Èõ¢Èñã</button>
        </div>
    </div>

    <!-- Settings Menu -->
    <div id="settings-menu" class="screen-overlay">
        <h1>Ë®≠ÂÆö</h1>
        <button class="menu-btn mode-switch" id="mode-switch-btn" onclick="switchViewMode()">ÂàáÊèõÊ®°Âºè: <span id="mode-text">ÈõªËÖ¶ (Â∑¶Âè≥ÂàÜÂâ≤)</span></button>
        <button class="menu-btn" onclick="toggleSettings()">‚ñ∂ ÁπºÁ∫åÈÅäÊà≤</button>
        <button class="menu-btn secondary" onclick="resetGame(true)">‚â° Âõû‰∏ªÈÅ∏ÂñÆ</button>
    </div>

    <!-- Victory Screen -->
    <div id="victory-screen" class="screen-overlay" onclick="resetGame(true)">
        <div class="victory-title" id="winner-text">P1 Áç≤Âãù!</div>
        <div class="victory-subtitle">ÈªûÊìäËû¢ÂπïÂõûÂà∞‰∏ªÈÅ∏ÂñÆ</div>
    </div>

    <!-- Training HUD -->
    <div id="training-hud">
        <div class="hud-row"><span>‰∏ñ‰ª£ (Gen):</span><span id="train-gen" class="hud-val">0</span></div>
        <div class="hud-row"><span>P1 ÂãùÂ†¥:</span><span id="train-p1-wins" class="hud-val" style="color:#ff5252">0</span></div>
        <div class="hud-row"><span>P2 ÂãùÂ†¥:</span><span id="train-p2-wins" class="hud-val" style="color:#448aff">0</span></div>
        <hr style="border-color:#333">
        <div class="hud-row"><span>Ë∑ùÈõ¢Ê¨äÈáç:</span><span id="train-w-dist" class="hud-val">10.0</span></div>
        <div class="hud-row"><span>ÁâÜÂ£ÅÊ¨äÈáç:</span><span id="train-w-wall" class="hud-val">1.0</span></div>
    </div>

    <!-- Main UI -->
    <div id="ui-layer">
        <button id="settings-btn" onclick="toggleSettings()">‚öôÔ∏è</button>

        <div id="divider"></div>
        <div id="label-p1" class="view-label">P1 (Á¥Ö)</div>
        <div id="label-p2" class="view-label">P2 (Ëóç)</div>

        <div id="status-bar">
            <span id="turn-msg" style="color: #ff5252">P1 ÂõûÂêà</span>
        </div>
        
        <div id="ai-thinking">‚ú® ÈõªËÖ¶ÊÄùËÄÉ‰∏≠...</div>

        <!-- Center Controls -->
        <div id="controls-center">
            <button id="speed-btn" class="action-btn" onclick="toggleSpeed()">üöÄ Ê•µÈÄüÊ®°Âºè: Èóú</button>
            <button id="undo-btn" class="action-btn" onclick="undoMove(event)" ontouchstart="undoMove(event)">‚Ü© ÊÇîÊ£ã</button>
            <button id="rotate-btn" class="action-btn" onclick="manualRotate()">ÊóãËΩâ (Ëá™Âãï)</button>
        </div>

        <!-- Wall Docks -->
        <!-- In Split mode: separate docks. In Single mode: shared dock at bottom -->
        <div id="dock-p1" class="wall-dock-container active">
            <div class="dock-label" id="dock-label-p1">P1 ÁâÜÂ£Å</div>
        </div>

        <div id="dock-p2" class="wall-dock-container">
            <div class="dock-label" id="dock-label-p2">P2 ÁâÜÂ£Å</div>
        </div>

        <!-- Opponent Info (Only visible in Single Mode / Online) -->
        <div id="dock-opp">
            <span style="color:#aaa; font-size:14px;">Â∞çÊâãÁâÜÂ£Å:</span>
            <span id="opp-walls-count" style="color:#448aff; font-weight:bold; font-size:20px;">10</span>
            <div style="width:10px; height:20px; background:#448aff; border-radius:2px;"></div>
        </div>
        
        <div id="toast">Ë®äÊÅØ</div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // --- CONFIG ---
        const firebaseConfig = {
            apiKey: "AIzaSyB5WQbvlEIm7J5wB9x_uuSMptSkkQ1Q1bE",
            authDomain: "quoridor-b1eb3.firebaseapp.com",
            projectId: "quoridor-b1eb3",
            storageBucket: "quoridor-b1eb3.firebasestorage.app",
            messagingSenderId: "976848451023",
            appId: "1:976848451023:web:b2db4117219ec12d69ceba",
            measurementId: "G-FE4G3KB80G"
        };

        const BOARD_SIZE = 9, CELL_W = 10, GAP_W = 2.5;
        const BOARD_W = BOARD_SIZE * CELL_W + (BOARD_SIZE - 1) * GAP_W;
        const DRAG_OFFSET_PIXELS = 120; 

        const COLORS = {
            boardBase: 0x3e2723, cellTop: 0x5d4037, wall: 0xeecc99,
            p1: 0xd32f2f, p2: 0x1976d2, highlight: 0x4caf50,
            wallGhostValid: 0xeecc99, wallGhostInvalid: 0xff5252
        };

        // --- GLOBAL STATE ---
        let db, auth, currentUser, unsubscribeRooms, unsubscribeGame, currentRoomId;

        let state = {
            started: false, paused: false, viewMode: 'split',
            turn: 1, processing: false,
            walls: { 1: 10, 2: 10 },
            pos: { 1: {x:4, y:0, goal:8}, 2: {x:4, y:8, goal:0} },
            placedWalls: new Set(),
            drag: { active: false, orientation: 'h', valid: false, gx: -1, gy: -1, sourceEl: null },
            gameType: 'pvp', // pvp, pve, train, online
            isAiThinking: false,
            history: [],
            training: { gen: 1, p1Wins: 0, p2Wins: 0, fastMode: false, weights: { dist: 10, wall: 1.0 } },
            online: { myPid: 1 }
        };

        let scene, renderer, cameraP1, cameraP2, cameraSingle;
        let objects = { pawns: {}, ghostWall: null, highlights: [], wallGroup: null };
        let raycaster, mouse, dragPlane;
        
        const audio = {
            move: new Audio('https://assets.mixkit.co/active_storage/sfx/2052/2052-preview.mp3'),
            drag: new Audio('https://assets.mixkit.co/active_storage/sfx/2568/2568-preview.mp3'),
            wall: new Audio('https://assets.mixkit.co/active_storage/sfx/2053/2053-preview.mp3'),
            win: new Audio('https://assets.mixkit.co/active_storage/sfx/2069/2069-preview.mp3')
        };
        for(let k in audio) audio[k].volume = 0.5;

        // --- INIT FIREBASE ---
        function initFirebase() {
            try {
                if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
                db = firebase.firestore(); auth = firebase.auth();
                auth.signInAnonymously().then(cred => {
                    currentUser = cred.user;
                    document.getElementById('player-id-display').innerText = `ID: ${currentUser.uid.substring(0,6)}`;
                }).catch(e => showToast("ÁÑ°Ê≥ïÈÄ£Á∑öËá≥‰º∫ÊúçÂô®"));
            } catch(e) { console.error(e); }
        }

        // --- GAME CONTROL ---
        function startGame(type) {
            state.gameType = type; state.started = true; state.processing = false;
            document.getElementById('start-screen').style.opacity = 0;
            document.getElementById('lobby-screen').style.display = 'none';

            // Reset UI Visibility
            document.getElementById('training-hud').style.display = 'none';
            document.getElementById('speed-btn').style.display = 'none';
            document.getElementById('undo-btn').style.display = 'block';
            document.getElementById('mode-switch-btn').style.display = 'block';

            if(type === 'online') {
                state.viewMode = 'single';
                document.getElementById('undo-btn').style.display = 'none'; // No undo in online
                document.getElementById('mode-switch-btn').style.display = 'none'; // Locked to single
                document.getElementById('settings-menu').style.display = 'none'; // Close menu if open
            } else if (type === 'train') {
                state.viewMode = 'split';
                document.getElementById('training-hud').style.display = 'block';
                document.getElementById('speed-btn').style.display = 'block';
                document.getElementById('undo-btn').style.display = 'none';
                // Trigger AI start after delay
                setTimeout(()=>triggerAI(1), 500);
            } else {
                // PvP / PvE
                state.viewMode = 'split'; 
                state.online.myPid = 1; // Default
                renderWallDocks();
            }

            // Apply view mode
            updateViewModeUI();
            updateCamera();
            setTimeout(() => document.getElementById('start-screen').style.display = 'none', 500);
            
            updateHUD();
            if(type!=='train' && type!=='online') showValidMoves();
        }

        function resetGame(toTitle) {
            state.started = false; state.paused = false; state.turn = 1; state.isAiThinking = false;
            state.walls = { 1: 10, 2: 10 };
            state.pos = { 1: {x:4, y:0, goal:8}, 2: {x:4, y:8, goal:0} };
            state.placedWalls = new Set();
            state.history = [];
            
            // Online cleanup
            if(unsubscribeGame) { unsubscribeGame(); unsubscribeGame=null; }
            if(state.gameType==='online' && currentRoomId) {
                if(state.online.myPid===1) db.collection('rooms').doc(currentRoomId).delete().catch(()=>{});
                else db.collection('rooms').doc(currentRoomId).update({"players.p2": firebase.firestore.FieldValue.delete()}).catch(()=>{});
                currentRoomId = null;
            }

            if (state.gameType !== 'train') { state.training.gen = 1; state.training.p1Wins = 0; state.training.p2Wins = 0; }

            // UI Reset
            document.getElementById('victory-screen').style.display = 'none';
            document.getElementById('settings-menu').style.display = 'none';
            document.getElementById('ai-thinking').style.display = 'none';
            document.getElementById('waiting-modal').style.display = 'none';
            document.getElementById('create-modal').style.display = 'none';
            document.getElementById('password-modal').style.display = 'none';
            
            if(toTitle) {
                document.getElementById('start-screen').style.display = 'flex';
                document.getElementById('start-screen').style.opacity = 1;
                document.getElementById('lobby-screen').style.display = 'none';
                state.viewMode = 'split'; updateViewModeUI();
            }

            // Visual Reset
            while(objects.wallGroup.children.length > 0) objects.wallGroup.remove(objects.wallGroup.children[0]);
            [1, 2].forEach(id => {
                const p = getGridPos(state.pos[id].x, state.pos[id].y);
                const v = new THREE.Vector3(p.x, 3, p.z);
                objects.pawns[id].target.copy(v); objects.pawns[id].mesh.position.copy(v);
            });
            renderWallDocks(); updateHUD();
        }

        function toggleSettings() {
            if(state.gameType==='online') return; // Simple pause not supported in online
            state.paused = !state.paused;
            document.getElementById('settings-menu').style.display = state.paused ? 'flex' : 'none';
        }

        function toggleSpeed() {
            state.training.fastMode = !state.training.fastMode;
            document.getElementById('speed-btn').innerText = `üöÄ Ê•µÈÄüÊ®°Âºè: ${state.training.fastMode ? 'Èñã' : 'Èóú'}`;
        }

        function switchViewMode() {
            if(state.gameType === 'online') return;
            state.viewMode = state.viewMode === 'split' ? 'single' : 'split';
            updateViewModeUI();
        }

        function updateViewModeUI() {
            document.body.className = state.viewMode === 'split' ? 'mode-split' : 'mode-single';
            const txt = state.viewMode === 'split' ? 'ÈõªËÖ¶ (Â∑¶Âè≥ÂàÜÂâ≤)' : 'Âπ≥Êùø (ÂÖ±Áî®Ê£ãÁõ§)';
            document.getElementById('mode-text').innerText = txt;
            document.getElementById('divider').style.display = state.viewMode === 'split' ? 'block' : 'none';
            document.getElementById('label-p2').style.display = state.viewMode === 'split' ? 'block' : 'none';
            document.getElementById('label-p1').style.display = state.viewMode === 'split' ? 'block' : 'none';
            
            // In Single mode, we use one dock at bottom, hide the other
            if(state.viewMode === 'single') {
                document.getElementById('dock-p1').style.display = 'flex'; // Shared/Swapped
                document.getElementById('dock-p2').style.display = 'none';
            } else {
                document.getElementById('dock-p1').style.display = 'flex';
                document.getElementById('dock-p2').style.display = 'flex';
            }
            // Trigger resize to fix camera aspect
            window.dispatchEvent(new Event('resize'));
            renderWallDocks();
            updateHUD();
        }

        // --- LOGIC & MOVE ---
        function saveHistory() {
            if(state.gameType === 'train' || state.gameType === 'online') return;
            state.history.push({
                turn: state.turn, walls: JSON.parse(JSON.stringify(state.walls)),
                pos: JSON.parse(JSON.stringify(state.pos)), placedWalls: Array.from(state.placedWalls)
            });
            if(state.history.length > 50) state.history.shift();
            updateHUD();
        }

        function undoMove(e) {
            if(e) { e.preventDefault(); e.stopPropagation(); }
            if(state.gameType === 'train' || state.gameType === 'online' || state.history.length === 0 || state.isAiThinking) return;
            
            let steps = (state.gameType === 'pve' && state.turn === 1 && state.history.length >= 2) ? 2 : 1;
            let target;
            for(let i=0; i<steps; i++) target = state.history.pop();
            
            if(target) {
                state.turn = target.turn; state.walls = target.walls; state.pos = target.pos; state.placedWalls = new Set(target.placedWalls);
                while(objects.wallGroup.children.length > 0) objects.wallGroup.remove(objects.wallGroup.children[0]);
                state.placedWalls.forEach(wStr => { const [x,y,o]=wStr.split(','); createWallMesh(parseInt(x),parseInt(y),o,false); });
                [1,2].forEach(id=>{ const p=getGridPos(state.pos[id].x, state.pos[id].y); objects.pawns[id].target.copy(new THREE.Vector3(p.x,3,p.z)); objects.pawns[id].mesh.position.copy(objects.pawns[id].target); });
                renderWallDocks(); updateHUD(); showValidMoves();
            }
        }

        function executeAction(act, isRemote) {
            if(state.processing) return;
            if(!isRemote) {
                if(state.gameType==='online' && state.turn!==state.online.myPid) return;
                state.processing = true;
                saveHistory();
            } else {
                // If it's my move echoed back, ignore or unlock
                if(act.by === state.online.myPid) return; 
            }

            if(act.type === 'move') {
                state.pos[act.by].x = act.x; state.pos[act.by].y = act.y;
                const p = getGridPos(act.x, act.y); objects.pawns[act.by].target.copy(new THREE.Vector3(p.x, 3, p.z));
                audio.move.currentTime = 0; audio.move.play().catch(()=>{});
            } else {
                state.walls[act.by]--; state.placedWalls.add(`${act.x},${act.y},${act.orientation}`);
                createWallMesh(act.x, act.y, act.orientation, true);
                audio.wall.currentTime = 0; audio.wall.play().catch(()=>{});
            }

            // Sync
            if(!isRemote && state.gameType === 'online') {
                db.collection('rooms').doc(currentRoomId).update({ "gameState.lastAction": { ...act, by: state.turn, ts: Date.now() } });
            }

            // Check Win
            if(state.pos[act.by].y === state.pos[act.by].goal) {
                if(state.gameType === 'train') {
                    handleTrainWin();
                } else {
                    audio.win.play().catch(()=>{});
                    document.getElementById('winner-text').innerText = (act.by===1?"P1 (Á¥Ö)":"P2 (Ëóç)") + " Áç≤Âãù!";
                    document.getElementById('victory-screen').style.display = 'flex';
                    state.paused = true;
                }
                state.processing = false;
                return;
            }

            // Next Turn
            state.turn = (state.turn === 1) ? 2 : 1;
            renderWallDocks(); // Refresh clickable state
            updateHUD();

            setTimeout(() => {
                state.processing = false;
                if(!isRemote) {
                    if(state.gameType==='pve' && state.turn===2) triggerAI(2);
                    else if(state.gameType==='train') triggerAI(state.turn);
                    else showValidMoves();
                } else {
                    if(state.gameType==='online' && state.turn===state.online.myPid) showValidMoves();
                }
            }, state.training.fastMode ? 10 : 300);
        }

        // --- THREE.JS SETUP ---
        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x1a1a1a);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; renderer.setScissorTest(true); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);
            
            cameraP1 = new THREE.PerspectiveCamera(40, window.innerWidth/2 / window.innerHeight, 0.1, 1000);
            cameraP1.position.set(0, 200, -140); cameraP1.lookAt(0, 0, 10);
            cameraP2 = new THREE.PerspectiveCamera(40, window.innerWidth/2 / window.innerHeight, 0.1, 1000);
            cameraP2.position.set(0, 200, 140); cameraP2.lookAt(0, 0, -10);
            cameraSingle = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            const hemi = new THREE.HemisphereLight(0xffeeb1, 0x080820, 0.4); scene.add(hemi);
            const dir = new THREE.DirectionalLight(0xfffaf0, 1.2); dir.position.set(30, 80, 50); dir.castShadow = true;
            dir.shadow.mapSize.width = 2048; dir.shadow.mapSize.height = 2048; scene.add(dir);

            createBoard(); createPawns(); objects.wallGroup = new THREE.Group(); scene.add(objects.wallGroup); createGhostWall();
            
            raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();
            dragPlane = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), new THREE.MeshBasicMaterial({visible:false}));
            dragPlane.rotation.x = -Math.PI/2; dragPlane.position.y = 8; scene.add(dragPlane);

            setupEvents(); animate(); initFirebase();
        }

        function createBoard() {
            const g = new THREE.Group();
            const b = new THREE.Mesh(new THREE.BoxGeometry(BOARD_W+6, 2, BOARD_W+6), new THREE.MeshStandardMaterial({color:COLORS.boardBase, roughness:0.8}));
            b.position.y = -1; b.receiveShadow=true; g.add(b);
            const gm = new THREE.BoxGeometry(CELL_W, 1.5, CELL_W);
            const mm = new THREE.MeshStandardMaterial({color:COLORS.cellTop, roughness:0.5});
            for(let y=0; y<BOARD_SIZE; y++) for(let x=0; x<BOARD_SIZE; x++) {
                const m=new THREE.Mesh(gm,mm); const p=getGridPos(x,y);
                m.position.set(p.x, 0.75, p.z); m.receiveShadow=true; m.castShadow=true; g.add(m);
            }
            scene.add(g);
        }
        function createPawns() {
            [1,2].forEach(id=>{
                const g=new THREE.Group(); const m=new THREE.MeshStandardMaterial({color:id===1?COLORS.p1:COLORS.p2, roughness:0.2});
                g.add(new THREE.Mesh(new THREE.CylinderGeometry(2.5, 3.5, 6, 32), m));
                const h=new THREE.Mesh(new THREE.SphereGeometry(3, 32, 16), m); h.position.y=4; g.add(h);
                g.traverse(o=>{if(o.isMesh)o.castShadow=true;});
                const p=getGridPos(state.pos[id].x,state.pos[id].y); g.position.set(p.x,3,p.z);
                objects.pawns[id]={mesh:g, target:new THREE.Vector3(p.x,3,p.z)}; scene.add(g);
            });
        }
        function createGhostWall() {
            const g = new THREE.BoxGeometry(CELL_W*2+GAP_W, 4, GAP_W*0.9);
            const m = new THREE.MeshBasicMaterial({color:COLORS.wall, transparent:true, opacity:0.6});
            objects.ghostWall = new THREE.Mesh(g,m); objects.ghostWall.visible=false; scene.add(objects.ghostWall);
        }
        function createWallMesh(x,y,o,anim=true) {
            const m = new THREE.Mesh(new THREE.BoxGeometry(CELL_W*2+GAP_W, 3.5, GAP_W*0.95), new THREE.MeshStandardMaterial({color:COLORS.wall, roughness:0.5}));
            const p = getWallPos(x,y,o); m.position.set(p.x, 10, p.z); m.rotation.y = p.angle;
            m.castShadow=true; m.receiveShadow=true; if(anim)m.userData={targetY:1.5}; else m.position.y=1.5;
            objects.wallGroup.add(m);
        }
        
        function updateCamera() {
            // Online/Single mode uses cameraSingle
            let myPid = (state.gameType === 'online') ? state.online.myPid : state.turn;
            if(state.gameType === 'pve' || state.gameType === 'train') myPid = 1; // P1 view always

            const z = myPid === 1 ? -130 : 130;
            const lookZ = myPid === 1 ? 10 : -10;
            cameraSingle.position.set(0, 160, z);
            cameraSingle.lookAt(0, 0, lookZ);
        }

        function getGridPos(gx, gy) { const s = -(BOARD_W/2) + CELL_W/2; const st = CELL_W + GAP_W; return { x: s + gx * st, z: s + gy * st }; }
        function getWallPos(gx, gy, o) { const s = -(BOARD_W/2) + CELL_W + GAP_W/2; const st = CELL_W + GAP_W; return { x: s + gx * st, z: s + gy * st, angle: o==='h'?0:Math.PI/2 }; }

        // --- GRID LOGIC ---
        function canStep(x1,y1,x2,y2) {
            if(x2<0||x2>8||y2<0||y2>8)return false;
            if(x1===x2){ const r=Math.min(y1,y2); if(state.placedWalls.has(`${x1},${r},h`)||state.placedWalls.has(`${x1-1},${r},h`))return false; }
            else{ const c=Math.min(x1,x2); if(state.placedWalls.has(`${c},${y1},v`)||state.placedWalls.has(`${c},${y1-1},v`))return false; }
            return true;
        }
        function getValidMoves(pid) {
            const m=[]; const p=state.pos[pid]; const opp=state.pos[pid===1?2:1];
            [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}].forEach(d=>{
                const nx=p.x+d.x, ny=p.y+d.y;
                if(canStep(p.x,p.y,nx,ny)){
                    if(nx===opp.x && ny===opp.y){
                        const jx=nx+d.x, jy=ny+d.y;
                        if(canStep(nx,ny,jx,jy)) m.push({x:jx,y:jy});
                        else {
                            if(d.x===0){ if(canStep(nx,ny,nx-1,ny))m.push({x:nx-1,y:ny}); if(canStep(nx,ny,nx+1,ny))m.push({x:nx+1,y:ny}); }
                            else{ if(canStep(nx,ny,nx,ny-1))m.push({x:nx,y:ny-1}); if(canStep(nx,ny,nx,ny+1))m.push({x:nx,y:ny+1}); }
                        }
                    } else m.push({x:nx,y:ny});
                }
            });
            return m;
        }
        function canPlaceWall(x,y,o) {
            if(x<0||x>7||y<0||y>7)return false;
            if(state.placedWalls.has(`${x},${y},h`)||state.placedWalls.has(`${x},${y},v`))return false;
            if(o==='h'&&(state.placedWalls.has(`${x-1},${y},h`)||state.placedWalls.has(`${x+1},${y},h`)))return false;
            if(o==='v'&&(state.placedWalls.has(`${x},${y-1},v`)||state.placedWalls.has(`${x},${y+1},v`)))return false;
            const k=`${x},${y},${o}`; state.placedWalls.add(k);
            const ok = getShortestPath(1)!==-1 && getShortestPath(2)!==-1;
            state.placedWalls.delete(k); return ok;
        }
        function getShortestPath(pid) {
            const q=[{x:state.pos[pid].x, y:state.pos[pid].y, d:0}]; const v=new Set([`${q[0].x},${q[0].y}`]); const g=state.pos[pid].goal;
            while(q.length){
                const c=q.shift(); if(c.y===g)return c.d;
                [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}].forEach(d=>{
                    const nx=c.x+d.x, ny=c.y+d.y;
                    if(canStep(c.x,c.y,nx,ny)&&!v.has(`${nx},${ny}`)){ v.add(`${nx},${ny}`); q.push({x:nx,y:ny,d:c.d+1}); }
                });
            } return -1;
        }

        // --- INTERACTION ---
        function renderWallDocks() {
            const showPid = (state.gameType==='online') ? state.online.myPid : state.turn;
            const oppPid = (showPid===1)?2:1;
            
            if(state.viewMode === 'split') {
                populateDock('dock-p1', 1, true);
                populateDock('dock-p2', 2, true);
                document.getElementById('dock-opp').style.display = 'none';
            } else {
                // Single Mode: dock-p1 is used as "My Dock"
                populateDock('dock-p1', showPid, true);
                document.getElementById('dock-label-p1').innerText = "ÊàëÁöÑÁâÜÂ£Å";
                
                // Show opponent walls
                document.getElementById('dock-opp').style.display = 'flex';
                document.getElementById('opp-walls-count').innerText = state.walls[oppPid];
            }
        }

        function populateDock(elId, pid, clickable) {
            const el = document.getElementById(elId); el.innerHTML = `<div class="dock-label" id="dock-label-${pid}">P${pid} ÁâÜÂ£Å</div>`;
            if(el.style.display==='none') return;
            const count = state.walls[pid];
            el.className = `wall-dock-container ${state.turn===pid ? 'active' : 'inactive'}`;
            for(let i=0; i<count; i++) {
                const w = document.createElement('div'); w.className = 'wall-item';
                if(pid===2) w.style.backgroundColor='#448aff';
                if(clickable && state.turn===pid) {
                    w.onmousedown=e=>startWallDrag(e, pid, w); w.ontouchstart=e=>startWallDrag(e, pid, w);
                }
                el.appendChild(w);
            }
        }

        function getPointerData(e, wd=false) {
            const w=window.innerWidth, h=window.innerHeight;
            let cx, cy, isTouch=false;
            if(e.changedTouches && e.changedTouches.length){ cx=e.changedTouches[0].clientX; cy=e.changedTouches[0].clientY; isTouch=true; }
            else if(e.touches && e.touches.length){ cx=e.touches[0].clientX; cy=e.touches[0].clientY; isTouch=true; }
            else { cx=e.clientX; cy=e.clientY; }

            if(wd && isTouch && state.viewMode==='single') {
                cy -= DRAG_OFFSET_PIXELS; // Offset so finger doesn't hide wall
            }

            let cam, ndcx, ndcy;
            if(state.viewMode==='single') {
                ndcx = (cx/w)*2-1; ndcy = -(cy/h)*2+1; cam = cameraSingle;
            } else {
                // Split logic
                if(cx < w/2) { ndcx=(cx/(w/2))*2-1; cam=cameraP1; }
                else { ndcx=((cx-w/2)/(w/2))*2-1; cam=cameraP2; }
                ndcy = -(cy/h)*2+1;
            }
            return { x:ndcx, y:ndcy, camera:cam, rawY:cy };
        }

        function manualRotate() { 
            state.drag.orientation = state.drag.orientation==='h'?'v':'h'; 
            document.getElementById('rotate-btn').innerText = `ÊóãËΩâ (${state.drag.orientation==='h'?'Ê©´':'Áõ¥'})`; 
        }

        function startWallDrag(e, pid, el) {
            if(!state.started||state.paused||state.processing)return;
            // Online Check
            if(state.gameType==='online' && state.turn!==state.online.myPid) return;
            // PvE Check
            if(state.gameType==='pve' && pid===2) return;
            // Train Check
            if(state.gameType==='train') return;
            // Turn Check
            if(state.turn!==pid) return;

            if(e.cancelable) e.preventDefault(); e.stopPropagation();
            audio.drag.currentTime=0; audio.drag.play().catch(()=>{});
            state.drag.active=true; state.drag.sourceEl=el; el.classList.add('dragging'); 
            objects.ghostWall.visible=true; handleMove(e);
        }

        function handleMove(e) {
            if(!state.drag.active) return;
            if(e.cancelable) e.preventDefault();
            const ptr = getPointerData(e, true);
            
            // Rejection logic (too low)
            if(ptr.rawY > window.innerHeight - 80) {
                objects.ghostWall.visible=false; state.drag.valid=false; return; 
            }
            objects.ghostWall.visible=true;
            if(!ptr.camera) return;

            mouse.set(ptr.x, ptr.y); raycaster.setFromCamera(mouse, ptr.camera);
            const hits = raycaster.intersectObject(dragPlane);
            if(hits.length>0) {
                const pt=hits[0].point;
                const st=CELL_W+GAP_W; const s=-(BOARD_W/2)+CELL_W+GAP_W/2;
                let gx=Math.round((pt.x-s)/st), gy=Math.round((pt.z-s)/st);
                
                // Auto orient
                let dx=Math.abs(((pt.x-s)/st)-gx), dy=Math.abs(((pt.z-s)/st)-gy);
                if(state.drag.orientation==='h') dy-=0.1; else dx-=0.1;
                state.drag.orientation = dx<dy?'v':'h';

                if(gx<0)gx=0; if(gx>7)gx=7; if(gy<0)gy=0; if(gy>7)gy=7;
                if(gx!==state.drag.gx || gy!==state.drag.gy){ audio.drag.currentTime=0; audio.drag.play().catch(()=>{}); }
                state.drag.gx=gx; state.drag.gy=gy;
                
                const valid=canPlaceWall(gx,gy,state.drag.orientation); state.drag.valid=valid;
                const p=getWallPos(gx,gy,state.drag.orientation); objects.ghostWall.position.set(p.x,6,p.z); objects.ghostWall.rotation.y=p.angle;
                objects.ghostWall.material.color.setHex(valid ? COLORS.wallGhostValid : COLORS.wallGhostInvalid);
            }
        }

        function handleUp(e) {
            if(state.drag.active){
                state.drag.active=false; objects.ghostWall.visible=false;
                if(state.drag.valid) {
                    executeAction({ type:'wall', x:state.drag.gx, y:state.drag.gy, orientation:state.drag.orientation, by:state.turn }, false);
                }
                if(state.drag.sourceEl) state.drag.sourceEl.classList.remove('dragging');
                state.drag.sourceEl=null;
            }
        }

        function handleClick(e) {
            if(state.drag.active||!state.started||state.paused||state.processing)return;
            // Online Check
            if(state.gameType==='online' && state.turn!==state.online.myPid) return;
            // PvE Check
            if(state.gameType==='pve' && state.turn===2) return;
            // Train Check
            if(state.gameType==='train') return;

            if(e.target.closest('button') || e.target.closest('.wall-dock-container') || e.target.closest('#settings-menu')) return;
            const ptr=getPointerData(e,false); if(!ptr.camera)return;
            mouse.set(ptr.x,ptr.y); raycaster.setFromCamera(mouse,ptr.camera);
            const hits=raycaster.intersectObjects(objects.highlights);
            if(hits.length>0){ 
                e.preventDefault(); 
                const d=hits[0].object.userData; 
                executeAction({ type:'move', x:d.x, y:d.y, by:state.turn }, false); 
            }
        }

        function showValidMoves() {
            objects.highlights.forEach(h=>scene.remove(h)); objects.highlights=[];
            if(state.processing || state.isAiThinking) return;
            // Don't show if not my turn (Online/PvE)
            if(state.gameType==='online' && state.turn!==state.online.myPid) return;
            if(state.gameType==='pve' && state.turn===2) return;
            if(state.gameType==='train') return;

            getValidMoves(state.turn).forEach(m=>{
                const g=new THREE.BoxGeometry(CELL_W*0.9,0.5,CELL_W*0.9); const mt=new THREE.MeshBasicMaterial({color:COLORS.highlight, transparent:true, opacity:0.5});
                const ms=new THREE.Mesh(g,mt); const p=getGridPos(m.x,m.y); ms.position.set(p.x,1.6,p.z); ms.userData={type:'move',x:m.x,y:m.y};
                scene.add(ms); objects.highlights.push(ms);
            });
        }

        function updateHUD() {
            const t=document.getElementById('turn-msg'); 
            let txt = `P${state.turn} ÂõûÂêà`;
            if(state.gameType==='online') {
                txt = (state.turn === state.online.myPid) ? "Ëº™Âà∞‰Ω†‰∫Ü" : "Â∞çÊâãÊÄùËÄÉ‰∏≠...";
                t.style.color = (state.turn === state.online.myPid) ? '#00e676' : '#aaa';
            } else {
                t.style.color = state.turn===1?'#ff5252':'#448aff';
            }
            t.innerText = txt;

            document.getElementById('undo-btn').style.opacity = state.history.length>0?1:0.5;
            
            // Train HUD
            if(state.gameType==='train'){
                document.getElementById('train-gen').innerText = state.training.gen;
                document.getElementById('train-p1-wins').innerText = state.training.p1Wins;
                document.getElementById('train-p2-wins').innerText = state.training.p2Wins;
                document.getElementById('train-w-dist').innerText = state.training.weights.dist.toFixed(1);
                document.getElementById('train-w-wall').innerText = state.training.weights.wall.toFixed(1);
            }
            
            renderWallDocks();
        }

        // --- AI (Safe Version) ---
        async function triggerAI(pid) {
            if(state.paused) return;
            state.isAiThinking = true;
            if(!state.training.fastMode) document.getElementById('ai-thinking').style.display='block';
            objects.highlights.forEach(h=>scene.remove(h)); objects.highlights=[];
            
            requestAnimationFrame(() => {
                setTimeout(() => {
                    let move = null;
                    try {
                        // Depth 2 for fast play/training, 3 for hard PvE
                        const depth = state.gameType==='train' ? 2 : 3;
                        move = minimaxRoot(depth, pid);
                    } catch(e) { console.error("AI Error", e); }
                    
                    // FALLBACK FIX: If AI fails to return a move (blocked or error), pick random valid move
                    if(!move) {
                        const valid = getValidMoves(pid);
                        if(valid.length > 0) {
                            const r = valid[Math.floor(Math.random()*valid.length)];
                            move = {type:'move', x:r.x, y:r.y};
                        }
                    }

                    state.isAiThinking = false;
                    document.getElementById('ai-thinking').style.display='none';
                    if(move) executeAction({ ...move, by:pid }, false);
                }, state.training.fastMode?10:50);
            });
        }

        function evaluateBoard(pid) {
            const myDist = getShortestPath(pid);
            const oppPid = pid===1?2:1;
            const oppDist = getShortestPath(oppPid);
            if(myDist === -1) return -10000;
            if(oppDist === -1) return 10000;
            const wD = state.gameType==='train' ? state.training.weights.dist : 15;
            const wW = state.gameType==='train' ? state.training.weights.wall : 2.0;
            return (oppDist - myDist) * wD + (state.walls[pid] - state.walls[oppPid]) * wW + Math.random();
        }

        function minimaxRoot(depth, pid) {
            let bestScore = -Infinity; let bestMoves = [];
            const moves = getAllCandidateMoves(pid);
            // Sort to improve alpha-beta pruning (moves first)
            moves.sort((a,b) => (a.type==='move' ? -1 : 1));
            
            for(let move of moves) {
                applyMove(move, pid);
                let score = minimax(depth-1, -Infinity, Infinity, false, pid);
                undoMoveCalc(move, pid);
                if(score > bestScore){ bestScore=score; bestMoves=[move]; }
                else if(score===bestScore) bestMoves.push(move);
            }
            return bestMoves.length>0 ? bestMoves[Math.floor(Math.random()*bestMoves.length)] : null;
        }

        function minimax(depth, alpha, beta, isMaximizing, rootPid) {
            if(depth===0) return evaluateBoard(rootPid);
            const currentPid = isMaximizing ? rootPid : (rootPid===1?2:1);
            
            // Win check
            if(state.pos[currentPid].y === state.pos[currentPid].goal) return isMaximizing ? 10000 : -10000;

            const moves = getAllCandidateMoves(currentPid);
            if(isMaximizing) {
                let maxEval = -Infinity;
                for(let move of moves) {
                    applyMove(move, currentPid);
                    let eval = minimax(depth-1, alpha, beta, false, rootPid);
                    undoMoveCalc(move, currentPid);
                    maxEval = Math.max(maxEval, eval); alpha = Math.max(alpha, eval);
                    if(beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for(let move of moves) {
                    applyMove(move, currentPid);
                    let eval = minimax(depth-1, alpha, beta, true, rootPid);
                    undoMoveCalc(move, currentPid);
                    minEval = Math.min(minEval, eval); beta = Math.min(beta, eval);
                    if(beta <= alpha) break;
                }
                return minEval;
            }
        }

        function getAllCandidateMoves(pid) {
            const candidates = []; const moves = getValidMoves(pid);
            for(let m of moves) candidates.push({ type: 'move', x: m.x, y: m.y });
            if(state.walls[pid] > 0) {
                const p1=state.pos[1]; const p2=state.pos[2];
                const range = 1; // Limit range for performance
                const targets=[p1, p2];
                const checked = new Set();
                targets.forEach(t => {
                    for(let dx=-range; dx<=range; dx++) for(let dy=-range; dy<=range; dy++) {
                        let wx=t.x+dx; let wy=t.y+dy;
                        if(wx<0||wx>7||wy<0||wy>7) continue;
                        for(let o of ['h','v']) {
                            const k=`${wx},${wy},${o}`; if(checked.has(k)) continue; checked.add(k);
                            if(canPlaceWall(wx,wy,o)) candidates.push({type:'wall', x:wx, y:wy, orientation:o});
                        }
                    }
                });
            }
            return candidates;
        }
        function applyMove(move, pid) {
            if(move.type === 'move') { move.prevX = state.pos[pid].x; move.prevY = state.pos[pid].y; state.pos[pid].x = move.x; state.pos[pid].y = move.y; }
            else { state.walls[pid]--; state.placedWalls.add(`${move.x},${move.y},${move.orientation}`); }
        }
        function undoMoveCalc(move, pid) {
            if(move.type === 'move') { state.pos[pid].x = move.prevX; state.pos[pid].y = move.prevY; }
            else { state.walls[pid]++; state.placedWalls.delete(`${move.x},${move.y},${move.orientation}`); }
        }

        function handleTrainWin() {
            if(state.turn===1) state.training.p1Wins++; else state.training.p2Wins++;
            state.training.gen++;
            // Simple Evolution: Random Mutation
            state.training.weights.dist += (Math.random()-0.5);
            state.training.weights.wall += (Math.random()-0.5);
            resetGame(); state.gameType = 'train';
            document.getElementById('start-screen').style.display='none';
            document.getElementById('training-hud').style.display='block';
            document.getElementById('speed-btn').style.display='block';
            document.getElementById('undo-btn').style.display='none';
            setTimeout(()=>triggerAI(1), 100);
        }

        function showToast(msg) {
            const t = document.getElementById('toast'); t.innerText=msg; t.style.opacity=1;
            setTimeout(()=>t.style.opacity=0, 2000);
        }

        // --- ANIMATE ---
        function setupEvents() {
            window.addEventListener('mousemove',e=>handleMove(e,false)); window.addEventListener('touchmove',e=>handleMove(e,false),{passive:false});
            window.addEventListener('mouseup',handleUp); window.addEventListener('touchend',handleUp);
            window.addEventListener('mousedown',handleClick); window.addEventListener('touchstart',handleClick,{passive:false});
            window.addEventListener('resize',()=>{
                const w=window.innerWidth, h=window.innerHeight; renderer.setSize(w,h);
                cameraSingle.aspect=w/h; cameraSingle.updateProjectionMatrix();
                cameraP1.aspect=(w/2)/h; cameraP1.updateProjectionMatrix(); cameraP2.aspect=(w/2)/h; cameraP2.updateProjectionMatrix();
            });
        }
        function animate() {
            requestAnimationFrame(animate);
            if((!state.paused || document.getElementById('victory-screen').style.display === 'flex') && !state.training.fastMode) {
                for(let id in objects.pawns) objects.pawns[id].mesh.position.lerp(objects.pawns[id].target, 0.2);
                objects.wallGroup.children.forEach(w => { if(w.userData.targetY && w.position.y>w.userData.targetY) w.position.y += (w.userData.targetY-w.position.y)*0.2; });
            }
            const w = window.innerWidth, h = window.innerHeight; renderer.clear();
            if(state.viewMode === 'single') { renderer.setViewport(0, 0, w, h); renderer.setScissor(0, 0, w, h); renderer.render(scene, cameraSingle); }
            else {
                renderer.setViewport(0, 0, w/2, h); renderer.setScissor(0, 0, w/2, h); renderer.render(scene, cameraP1);
                renderer.setViewport(w/2, 0, w/2, h); renderer.setScissor(w/2, 0, w/2, h); renderer.render(scene, cameraP2);
            }
        }

        // --- LOBBY FUNCTIONS ---
        function openLobby() { document.getElementById('start-screen').style.display='none'; document.getElementById('lobby-screen').style.display='flex'; unsubscribeRooms=db.collection('rooms').where('status','==','waiting').onSnapshot(snap=>{ const l=document.getElementById('room-list'); l.innerHTML=''; if(snap.empty){l.innerHTML='<div style="text-align:center;padding:20px;color:#888">ÁÑ°ÊàøÈñì</div>';return;} snap.forEach(d=>{ const r=d.data(); const div=document.createElement('div'); div.className=`room-item ${r.isPrivate?'private':''}`; div.innerHTML=`<div><div class="room-name">${r.name}</div><div class="room-status">${r.isPrivate?'üîí':'üåê'} ${r.hostName}</div></div><button class="menu-btn small online" style="margin:0; width:auto; padding:5px 15px; font-size:14px;">Âä†ÂÖ•</button>`; div.onclick=()=>tryJoin(d.id,r); l.appendChild(div); }) }); }
        function closeLobby() { if(unsubscribeRooms)unsubscribeRooms(); document.getElementById('lobby-screen').style.display='none'; document.getElementById('start-screen').style.display='flex'; }
        function showCreateRoom() { document.getElementById('create-modal').style.display='flex'; }
        function togglePasswordInput() { document.getElementById('room-password').style.display=document.getElementById('is-private').checked?'block':'none'; }
        function createRoom() { const name=document.getElementById('new-room-name').value||"Room"; const isPrivate=document.getElementById('is-private').checked; const pwd=document.getElementById('room-password').value; if(isPrivate&&pwd.length!==6)return showToast("Ë´ãËº∏ÂÖ•6‰ΩçÂØÜÁ¢º"); db.collection('rooms').add({name,isPrivate,password:isPrivate?pwd:null,hostId:currentUser.uid,hostName:"P-"+currentUser.uid.substring(0,4),status:'waiting',players:{p1:currentUser.uid},gameState:{turn:1}}).then(d=>{currentRoomId=d.id;state.online.myPid=1;document.getElementById('create-modal').style.display='none';waitForP2(d.id)}); }
        function waitForP2(rid) { document.getElementById('wait-room-id').innerText=rid.substring(0,6); document.getElementById('waiting-modal').style.display='flex'; unsubscribeGame=db.collection('rooms').doc(rid).onSnapshot(d=>{ if(!d.exists)return resetGame(true); const data=d.data(); if(data.players.p2){ document.getElementById('waiting-modal').style.display='none'; document.getElementById('lobby-screen').style.display='none'; startGame('online'); } if(data.status==='playing'&&data.gameState.lastAction) executeAction(data.gameState.lastAction,true); }); }
        let pendingJoinId; function tryJoin(rid,r){ if(r.isPrivate){pendingJoinId=rid;document.getElementById('join-room-name').innerText=r.name;document.getElementById('password-modal').style.display='flex';}else doJoin(rid); }
        function submitPassword(){ db.collection('rooms').doc(pendingJoinId).get().then(d=>{if(d.data().password==document.getElementById('join-password').value){document.getElementById('password-modal').style.display='none';doJoin(pendingJoinId);}else showToast("ÂØÜÁ¢ºÈåØË™§");}); }
        function closePasswordModal(){document.getElementById('password-modal').style.display='none';}
        function doJoin(rid){ db.collection('rooms').doc(rid).update({"players.p2":currentUser.uid,status:'playing',"gameState.turn":1}).then(()=>{ currentRoomId=rid; state.online.myPid=2; document.getElementById('lobby-screen').style.display='none'; startGame('online'); unsubscribeGame=db.collection('rooms').doc(rid).onSnapshot(d=>{ if(!d.exists)return resetGame(true); const data=d.data(); if(data.gameState.lastAction) executeAction(data.gameState.lastAction,true); }); }).catch(()=>showToast("Âä†ÂÖ•Â§±Êïó")); }
        function leaveRoom(){ if(currentRoomId){ if(state.online.myPid===1)db.collection('rooms').doc(currentRoomId).delete(); else db.collection('rooms').doc(currentRoomId).update({"players.p2":firebase.firestore.FieldValue.delete()}); } resetGame(true); }

        initFirebase(); init();
    </script>
</body>
</html>