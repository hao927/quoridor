<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Quoridor 3D - Online & AI</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #111; user-select: none; touch-action: none; }
        
        /* --- UI Screens --- */
        .screen-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9); z-index: 2000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; transition: opacity 0.5s;
        }

        #start-screen { z-index: 2001; background: url('https://images.unsplash.com/photo-1611195974226-a6a9be9dd763?q=80&w=1925') center/cover; }
        #start-screen::before { content:''; position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:-1; }
        
        #online-menu { display: none; z-index: 2002; background: rgba(0,0,0,0.95); }
        #settings-menu { display: none; background: rgba(0,0,0,0.9); backdrop-filter: blur(8px); z-index: 2002; }
        
        h1 { font-size: 50px; margin-bottom: 30px; text-shadow: 0 0 20px rgba(255,255,255,0.3); letter-spacing: 2px; text-align: center; }
        h2 { font-size: 24px; color: #aaa; margin-bottom: 20px; }

        .menu-btn {
            background: linear-gradient(135deg, #448aff, #1976d2); border: none; color: white;
            padding: 15px 30px; margin: 10px; font-size: 18px; border-radius: 8px; cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3); width: 280px; font-weight: bold; transition: 0.2s;
        }
        .menu-btn:active { transform: scale(0.95); }
        .menu-btn.ai { background: linear-gradient(135deg, #7b1fa2, #4a148c); }
        .menu-btn.online { background: linear-gradient(135deg, #00c853, #00695c); }
        .menu-btn.secondary { background: #444; border: 1px solid #666; }

        /* Online Inputs */
        .input-group { margin: 10px; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        input[type="text"] {
            padding: 10px; font-size: 18px; border-radius: 5px; border: 1px solid #555; background: #222; color: white; text-align: center; width: 200px;
        }
        #room-id-display { font-family: monospace; font-size: 24px; color: #00e676; margin: 10px; padding: 10px; border: 1px dashed #555; user-select: text; cursor: pointer; }
        .copy-hint { font-size: 12px; color: #888; margin-top: -5px; }

        /* HUD & Controls */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        #status-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(20, 20, 20, 0.85); padding: 10px 40px; border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1); color: #eee; font-size: 18px; font-weight: bold;
            pointer-events: auto; z-index: 101; white-space: nowrap;
        }
        
        #ai-thinking {
            position: absolute; top: 70px; left: 50%; transform: translateX(-50%);
            background: rgba(123, 31, 162, 0.9); color: white; padding: 5px 15px; border-radius: 20px;
            display: none; z-index: 102; font-size: 14px;
        }

        .wall-dock-container {
            position: absolute; width: 35%; height: 70px; background: rgba(0,0,0,0.5); border-radius: 16px;
            display: flex; align-items: center; justify-content: center; gap: 6px; padding: 0 15px;
            pointer-events: auto; transition: 0.3s; z-index: 102;
        }
        .wall-dock-container.active { background: rgba(255,255,255,0.1); box-shadow: 0 0 15px rgba(255,255,255,0.1); }
        .mode-split #dock-p1 { bottom: 20px; left: 2%; }
        .mode-split #dock-p2 { bottom: 20px; right: 2%; }
        .wall-item { width: 12px; height: 40px; background: #d4a373; border-radius: 3px; cursor: grab; position: relative; }
        .wall-item.disabled { opacity: 0.3; cursor: not-allowed; }
        .dock-label { position: absolute; top: -25px; font-size: 14px; color: #aaa; width: 100%; text-align: center; }

        #controls-center {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; pointer-events: auto; z-index: 200;
        }
        .action-btn {
            background: #444; color: white; border: 1px solid rgba(255,255,255,0.3);
            padding: 10px 20px; border-radius: 10px; font-size: 16px; cursor: pointer;
        }
        #settings-btn { position: absolute; top: 20px; left: 20px; width: 40px; height: 40px; border-radius: 50%; background: #333; color: white; border: none; cursor: pointer; pointer-events: auto; z-index: 150; font-size: 20px; }

        /* Victory */
        #victory-screen { display: none; z-index: 2003; cursor: pointer; }
        .victory-title { font-size: 60px; font-weight: bold; margin-bottom: 10px; }

        /* Toast */
        #toast {
            position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
            background: rgba(50, 50, 50, 0.9); color: white; padding: 10px 20px; border-radius: 5px;
            z-index: 3000; opacity: 0; transition: opacity 0.3s; pointer-events: none;
        }
    </style>
</head>
<body class="mode-split">

    <div id="start-screen" class="screen-overlay">
        <h1>Quoridor 3D</h1>
        <button class="menu-btn" onclick="startGame('pvp')">üë• Êú¨Âú∞Èõô‰∫∫ (Local)</button>
        <button class="menu-btn ai" onclick="startGame('pve')">ü§ñ ÊåëÊà∞ AI (PvE)</button>
        <button class="menu-btn online" onclick="showOnlineMenu()">üåê Á∑ö‰∏äÂ∞çÊà∞ (Online)</button>
    </div>

    <div id="online-menu" class="screen-overlay">
        <h1>Á∑ö‰∏äÂ∞çÊà∞</h1>
        <div id="online-loading" style="display:none; color:#00e676">ÈÄ£Á∑ö‰º∫ÊúçÂô®‰∏≠...</div>
        
        <div id="online-options">
            <button class="menu-btn online" onclick="hostGame()">üè† Âª∫Á´ãÊàøÈñì (Host)</button>
            <div style="margin: 10px; color: #aaa">- OR -</div>
            <div class="input-group">
                <input type="text" id="join-id-input" placeholder="Ëº∏ÂÖ•ÊàøÈñì ID">
                <button class="menu-btn" onclick="joinGame()">üîó Âä†ÂÖ•ÊàøÈñì (Join)</button>
            </div>
        </div>

        <div id="host-ui" style="display:none; text-align:center;">
            <h2>Á≠âÂæÖÂ∞çÊâãÂä†ÂÖ•...</h2>
            <div id="room-id-display" onclick="copyRoomId()">---</div>
            <div class="copy-hint">(ÈªûÊìäË§áË£Ω ID ÂÇ≥Áµ¶ÊúãÂèã)</div>
            <br>
            <button class="menu-btn secondary" onclick="cancelOnline()">ÂèñÊ∂à</button>
        </div>

        <button class="menu-btn secondary" onclick="cancelOnline()" style="margin-top:20px">ËøîÂõû</button>
    </div>

    <div id="settings-menu" class="screen-overlay">
        <h1>Êö´ÂÅú</h1>
        <button class="menu-btn" onclick="toggleSettings()">‚ñ∂ ÁπºÁ∫åÈÅäÊà≤</button>
        <button class="menu-btn secondary" onclick="resetGame(true)">‚â° Âõû‰∏ªÈÅ∏ÂñÆ</button>
    </div>

    <div id="victory-screen" class="screen-overlay" onclick="resetGame(true)">
        <div class="victory-title" id="winner-text">P1 Áç≤Âãù!</div>
        <div style="color:#aaa">ÈªûÊìäËû¢ÂπïÂõûÂà∞‰∏ªÈÅ∏ÂñÆ</div>
    </div>

    <div id="ui-layer">
        <button id="settings-btn" onclick="toggleSettings()">‚öôÔ∏è</button>
        <div id="status-bar"><span id="turn-msg">P1 ÂõûÂêà</span></div>
        <div id="ai-thinking">‚ú® AI ÊÄùËÄÉ‰∏≠...</div>

        <div id="controls-center">
            <button id="rotate-btn" class="action-btn" onclick="manualRotate()">ÊóãËΩâ (Ëá™Âãï)</button>
        </div>

        <div id="dock-p1" class="wall-dock-container"><div class="dock-label">P1 ÁâÜÂ£Å</div></div>
        <div id="dock-p2" class="wall-dock-container"><div class="dock-label">P2 ÁâÜÂ£Å</div></div>
        <div id="toast">Ë®äÊÅØ</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Game Constants ---
        const BOARD_SIZE = 9, CELL_W = 10, GAP_W = 2.5;
        const BOARD_W = BOARD_SIZE * CELL_W + (BOARD_SIZE - 1) * GAP_W;
        const COLORS = { board: 0x3e2723, cell: 0x5d4037, wall: 0xeecc99, p1: 0xd32f2f, p2: 0x1976d2, highlight: 0x4caf50 };

        // --- Global State ---
        let state = {
            started: false, paused: false, turn: 1,
            walls: { 1: 10, 2: 10 },
            pos: { 1: {x:4, y:0, goal:8}, 2: {x:4, y:8, goal:0} },
            placedWalls: new Set(),
            gameType: 'pvp', // 'pvp', 'pve', 'online'
            isAiThinking: false,
            // Online Specific
            online: {
                isHost: false,
                myPid: 1, // 1 for Host, 2 for Client
                conn: null,
                peer: null
            },
            drag: { active: false, orientation: 'h', valid: false, gx: -1, gy: -1, sourceEl: null }
        };

        // --- Three.js Globals ---
        let scene, renderer, cameraP1, cameraP2;
        let objects = { pawns: {}, ghostWall: null, highlights: [], wallGroup: null };
        let raycaster, mouse, dragPlane;
        
        // --- Audio ---
        const audio = {
            move: new Audio('https://assets.mixkit.co/active_storage/sfx/2052/2052-preview.mp3'),
            wall: new Audio('https://assets.mixkit.co/active_storage/sfx/2053/2053-preview.mp3'),
            win: new Audio('https://assets.mixkit.co/active_storage/sfx/2069/2069-preview.mp3')
        };

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x1a1a1a);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setScissorTest(true);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            cameraP1 = new THREE.PerspectiveCamera(40, window.innerWidth/2/window.innerHeight, 0.1, 1000);
            cameraP1.position.set(0, 200, -140); cameraP1.lookAt(0,0,10);
            cameraP2 = new THREE.PerspectiveCamera(40, window.innerWidth/2/window.innerHeight, 0.1, 1000);
            cameraP2.position.set(0, 200, 140); cameraP2.lookAt(0,0,-10);

            setupLighting(); createBoard(); createPawns();
            objects.wallGroup = new THREE.Group(); scene.add(objects.wallGroup);
            createGhostWall();

            raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();
            dragPlane = new THREE.Mesh(new THREE.PlaneGeometry(500,500), new THREE.MeshBasicMaterial({visible:false}));
            dragPlane.rotation.x = -Math.PI/2; dragPlane.position.y = 8; scene.add(dragPlane);

            setupEvents(); animate();
        }

        function setupLighting() {
            scene.add(new THREE.HemisphereLight(0xffeeb1, 0x080820, 0.4));
            const l = new THREE.DirectionalLight(0xfffaf0, 1.2); l.position.set(30,80,50); l.castShadow = true;
            l.shadow.mapSize.width=2048; l.shadow.mapSize.height=2048; scene.add(l);
        }
        function createBoard() {
            const g = new THREE.Group();
            const b = new THREE.Mesh(new THREE.BoxGeometry(BOARD_W+6, 2, BOARD_W+6), new THREE.MeshStandardMaterial({color:COLORS.board, roughness:0.8}));
            b.position.y = -1; b.receiveShadow=true; g.add(b);
            const gm = new THREE.BoxGeometry(CELL_W, 1.5, CELL_W);
            const mm = new THREE.MeshStandardMaterial({color:COLORS.cell, roughness:0.5});
            for(let y=0; y<BOARD_SIZE; y++) for(let x=0; x<BOARD_SIZE; x++) {
                const m = new THREE.Mesh(gm,mm); const p = getGridPos(x,y);
                m.position.set(p.x, 0.75, p.z); m.receiveShadow=true; m.castShadow=true; g.add(m);
            }
            scene.add(g);
        }
        function createPawns() {
            [1,2].forEach(id=>{
                const gr = new THREE.Group();
                const m = new THREE.MeshStandardMaterial({color: id===1?COLORS.p1:COLORS.p2});
                gr.add(new THREE.Mesh(new THREE.CylinderGeometry(2.5,3.5,6,32), m));
                const h = new THREE.Mesh(new THREE.SphereGeometry(3,32,16), m); h.position.y=4; gr.add(h);
                gr.traverse(o=>{if(o.isMesh)o.castShadow=true;});
                const p = getGridPos(state.pos[id].x, state.pos[id].y); gr.position.set(p.x,3,p.z);
                objects.pawns[id] = {mesh:gr, target:new THREE.Vector3(p.x,3,p.z)}; scene.add(gr);
            });
        }
        function createGhostWall() {
            objects.ghostWall = new THREE.Mesh(new THREE.BoxGeometry(CELL_W*2+GAP_W, 4, GAP_W*0.9), new THREE.MeshBasicMaterial({color:COLORS.wall, transparent:true, opacity:0.6}));
            objects.ghostWall.visible=false; scene.add(objects.ghostWall);
        }

        // --- Core Logic ---
        function getGridPos(gx, gy) {
            const st = CELL_W+GAP_W; const s = -(BOARD_W/2)+CELL_W/2;
            return { x: s + gx*st, z: s + gy*st };
        }
        function getWallPos(gx, gy, o) {
            const st = CELL_W+GAP_W; const s = -(BOARD_W/2)+CELL_W+GAP_W/2;
            return { x: s + gx*st, z: s + gy*st, angle: o==='h'?0:Math.PI/2 };
        }
        function canStep(x1,y1,x2,y2) {
            if(x2<0||x2>=9||y2<0||y2>=9) return false;
            if(x1===x2){ const r=Math.min(y1,y2); if(state.placedWalls.has(`${x1},${r},h`)||state.placedWalls.has(`${x1-1},${r},h`))return false; }
            else{ const c=Math.min(x1,x2); if(state.placedWalls.has(`${c},${y1},v`)||state.placedWalls.has(`${c},${y1-1},v`))return false; }
            return true;
        }
        function getValidMoves(pid) {
            const m=[]; const p=state.pos[pid]; const opp=state.pos[pid===1?2:1];
            [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}].forEach(d=>{
                const nx=p.x+d.x, ny=p.y+d.y;
                if(canStep(p.x,p.y,nx,ny)){
                    if(nx===opp.x && ny===opp.y){
                        const jx=nx+d.x, jy=ny+d.y;
                        if(canStep(nx,ny,jx,jy)) m.push({x:jx,y:jy});
                        else { // Jump sideways
                            if(d.x===0){ if(canStep(nx,ny,nx-1,ny))m.push({x:nx-1,y:ny}); if(canStep(nx,ny,nx+1,ny))m.push({x:nx+1,y:ny}); }
                            else{ if(canStep(nx,ny,nx,ny-1))m.push({x:nx,y:ny-1}); if(canStep(nx,ny,nx,ny+1))m.push({x:nx,y:ny+1}); }
                        }
                    } else m.push({x:nx,y:ny});
                }
            });
            return m;
        }
        function canPlaceWall(x,y,o) {
            if(x<0||x>=8||y<0||y>=8) return false;
            const k=`${x},${y},`; 
            if(state.placedWalls.has(k+'h')||state.placedWalls.has(k+'v')) return false;
            if(o==='h'&&(state.placedWalls.has(`${x-1},${y},h`)||state.placedWalls.has(`${x+1},${y},h`))) return false;
            if(o==='v'&&(state.placedWalls.has(`${x},${y-1},v`)||state.placedWalls.has(`${x},${y+1},v`))) return false;
            // Check Path Check
            state.placedWalls.add(k+o);
            const ok = getShortestPath(1)!==-1 && getShortestPath(2)!==-1;
            state.placedWalls.delete(k+o);
            return ok;
        }
        function getShortestPath(pid) {
            const q=[{x:state.pos[pid].x, y:state.pos[pid].y, d:0}]; const v=new Set([`${q[0].x},${q[0].y}`]); const g=state.pos[pid].goal;
            while(q.length){
                const c=q.shift(); if(c.y===g) return c.d;
                [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}].forEach(d=>{
                    const nx=c.x+d.x, ny=c.y+d.y;
                    if(canStep(c.x,c.y,nx,ny)&&!v.has(`${nx},${ny}`)){ v.add(`${nx},${ny}`); q.push({x:nx,y:ny,d:c.d+1}); }
                });
            } return -1;
        }

        // --- Game Control ---
        function startGame(type) {
            state.gameType = type; state.started = true;
            document.getElementById('start-screen').style.opacity=0;
            setTimeout(()=>document.getElementById('start-screen').style.display='none', 500);
            
            // Online Mode Logic
            if(type === 'online') {
                // If I am P2, I can't move yet
                if(state.online.myPid === 2) {
                    showToast("Â∑≤ÈÄ£Á∑öÔºÅÁ≠âÂæÖ P1 ÁßªÂãï...");
                }
            }
            
            resetBoardVisuals();
            renderWallDocks();
            updateHUD();
            showValidMoves();
        }

        function resetGame(fullReset=false) {
            state.started = false; state.paused = false; state.turn = 1;
            state.walls = {1:10, 2:10};
            state.pos = {1:{x:4,y:0,goal:8}, 2:{x:4,y:8,goal:0}};
            state.placedWalls.clear();
            state.isAiThinking = false;

            document.getElementById('victory-screen').style.display='none';
            document.getElementById('settings-menu').style.display='none';
            document.getElementById('ai-thinking').style.display='none';
            document.getElementById('online-menu').style.display='none';

            if(fullReset) {
                // Clean up Peer
                if(state.online.peer) { state.online.peer.destroy(); state.online.peer = null; }
                state.online.conn = null;
                document.getElementById('start-screen').style.display='flex';
                document.getElementById('start-screen').style.opacity=1;
            }

            resetBoardVisuals();
        }

        function resetBoardVisuals() {
            while(objects.wallGroup.children.length>0) objects.wallGroup.remove(objects.wallGroup.children[0]);
            [1,2].forEach(id=>{
                const p = getGridPos(state.pos[id].x, state.pos[id].y);
                objects.pawns[id].target.copy(new THREE.Vector3(p.x,3,p.z));
                objects.pawns[id].mesh.position.copy(objects.pawns[id].target);
            });
            renderWallDocks();
            updateHUD();
        }

        // --- Interaction ---
        function getPointerData(e, wd=false) {
            const w=window.innerWidth, h=window.innerHeight;
            let cx, cy, isTouch=false;
            if(e.changedTouches){ cx=e.changedTouches[0].clientX; cy=e.changedTouches[0].clientY; isTouch=true; }
            else { cx=e.clientX; cy=e.clientY; }
            
            if(wd && isTouch) cy-=120; // Touch offset for wall dock
            
            let cam, ndcx;
            if(cx<w/2){ ndcx=(cx/(w/2))*2-1; cam=cameraP1; } else { ndcx=((cx-w/2)/(w/2))*2-1; cam=cameraP2; }
            const ndcy = -(cy/h)*2+1;
            return { x:ndcx, y:ndcy, camera:cam, rawY:isTouch?cy:e.clientY };
        }

        function handleClick(e) {
            if(!state.started || state.paused || state.isAiThinking || state.drag.active) return;
            
            // Online Check
            if(state.gameType === 'online' && state.turn !== state.online.myPid) return;
            // PvE Check
            if(state.gameType === 'pve' && state.turn === 2) return;

            if(e.target.closest('.wall-dock-container') || e.target.closest('button')) return;

            const ptr = getPointerData(e); if(!ptr.camera) return;
            mouse.set(ptr.x, ptr.y); raycaster.setFromCamera(mouse, ptr.camera);
            
            const hits = raycaster.intersectObjects(objects.highlights);
            if(hits.length>0) {
                const d = hits[0].object.userData;
                executeMove({ type:'move', x:d.x, y:d.y });
            }
        }

        function startWallDrag(e, pid, el) {
            if(!state.started || state.paused || state.turn !== pid) return;
            // Online Check
            if(state.gameType === 'online' && state.turn !== state.online.myPid) return;
            // PvE Check
            if(state.gameType === 'pve' && pid === 2) return;

            e.preventDefault(); e.stopPropagation();
            state.drag.active=true; state.drag.sourceEl=el; el.classList.add('dragging');
            objects.ghostWall.visible=true; handleMove(e);
        }

        function handleMove(e) {
            if(!state.drag.active) return;
            e.preventDefault();
            const ptr = getPointerData(e, true);
            
            // Check dock collision
            const h = window.innerHeight;
            if(ptr.rawY > h-120) { objects.ghostWall.visible=false; state.drag.valid=false; return; }
            
            objects.ghostWall.visible=true;
            mouse.set(ptr.x, ptr.y); raycaster.setFromCamera(mouse, ptr.camera);
            const hits = raycaster.intersectObject(dragPlane);
            
            if(hits.length>0) {
                const pt = hits[0].point;
                const st = CELL_W+GAP_W; const s = -(BOARD_W/2)+CELL_W+GAP_W/2;
                let gx = Math.round((pt.x-s)/st), gy = Math.round((pt.z-s)/st);
                
                let dx = Math.abs(((pt.x-s)/st)-gx), dy = Math.abs(((pt.z-s)/st)-gy);
                if(state.drag.orientation==='h') dy-=0.1; else dx-=0.1;
                state.drag.orientation = dx<dy?'v':'h';

                if(gx<0)gx=0; if(gx>7)gx=7; if(gy<0)gy=0; if(gy>7)gy=7;
                
                const valid = canPlaceWall(gx, gy, state.drag.orientation);
                state.drag.gx = gx; state.drag.gy = gy; state.drag.valid = valid;
                
                const p = getWallPos(gx, gy, state.drag.orientation);
                objects.ghostWall.position.set(p.x, 6, p.z);
                objects.ghostWall.rotation.y = p.angle;
                objects.ghostWall.material.color.setHex(valid ? COLORS.wall : 0xff0000);
            }
        }

        function handleUp(e) {
            if(state.drag.active) {
                state.drag.active=false; objects.ghostWall.visible=false;
                if(state.drag.sourceEl) state.drag.sourceEl.classList.remove('dragging');
                
                if(state.drag.valid) {
                    executeMove({ type:'wall', x:state.drag.gx, y:state.drag.gy, orientation:state.drag.orientation });
                }
                state.drag.sourceEl=null;
            }
        }

        // --- Action Execution (Local & Network) ---
        function executeMove(moveData) {
            // Apply locally
            if(moveData.type === 'move') {
                movePlayer(moveData.x, moveData.y);
            } else {
                placeWall(moveData.x, moveData.y, moveData.orientation);
            }

            // Send to Network if Online
            if(state.gameType === 'online' && state.online.conn && state.online.conn.open) {
                // Only send if I originated the move (it's my turn)
                // If I am just receiving a move from network, don't send it back loop
                // We handle this by checking logic in network listener
                 if(state.turn !== state.online.myPid) {
                     // This was an opponent move application, do not broadcast
                 } else {
                     state.online.conn.send(moveData);
                 }
            }
        }

        function movePlayer(x, y) {
            state.pos[state.turn].x = x; state.pos[state.turn].y = y;
            const p = getGridPos(x,y); objects.pawns[state.turn].target.copy(new THREE.Vector3(p.x,3,p.z));
            audio.move.currentTime=0; audio.move.play().catch(()=>{});
            
            checkWin();
            nextTurn();
        }

        function placeWall(x, y, o) {
            state.walls[state.turn]--;
            state.placedWalls.add(`${x},${y},${o}`);
            
            const m = new THREE.Mesh(new THREE.BoxGeometry(CELL_W*2+GAP_W, 3.5, GAP_W*0.95), new THREE.MeshStandardMaterial({color:COLORS.wall}));
            const p = getWallPos(x,y,o); m.position.set(p.x, 10, p.z); m.rotation.y = p.angle;
            m.castShadow=true; m.receiveShadow=true; m.userData={targetY:1.5};
            objects.wallGroup.add(m);
            
            audio.wall.play().catch(()=>{});
            
            // Update dock UI
            const dockId = state.turn === 1 ? 'dock-p1' : 'dock-p2';
            const dock = document.getElementById(dockId);
            if(dock.children.length > 1) dock.lastElementChild.remove();

            nextTurn();
        }

        function nextTurn() {
            state.turn = state.turn===1 ? 2 : 1;
            updateHUD();
            
            // AI Trigger
            if(state.gameType === 'pve' && state.turn === 2) {
                setTimeout(triggerAI, 500);
            } else {
                showValidMoves();
            }
        }

        function checkWin() {
            if(state.pos[state.turn].y === state.pos[state.turn].goal) {
                audio.win.play().catch(()=>{});
                document.getElementById('winner-text').innerText = state.turn===1 ? 'P1 Áç≤Âãù!' : 'P2 Áç≤Âãù!';
                document.getElementById('winner-text').style.color = state.turn===1 ? '#ff5252' : '#448aff';
                document.getElementById('victory-screen').style.display='flex';
                state.paused = true;
            }
        }

        function updateHUD() {
            const t = document.getElementById('turn-msg');
            let txt = `P${state.turn} ÂõûÂêà`;
            if(state.gameType === 'online') {
                txt += (state.turn === state.online.myPid) ? " (‰Ω†)" : " (Â∞çÊâã)";
            }
            t.innerText = txt;
            t.style.color = state.turn===1 ? '#ff5252' : '#448aff';
            
            document.getElementById('dock-p1').classList.toggle('active', state.turn===1);
            document.getElementById('dock-p2').classList.toggle('active', state.turn===2);
        }

        // --- Optimized AI ---
        function triggerAI() {
            state.isAiThinking = true;
            document.getElementById('ai-thinking').style.display='block';
            objects.highlights.forEach(h=>scene.remove(h)); objects.highlights=[];
            
            setTimeout(() => {
                const move = calculateBestMove(2);
                state.isAiThinking = false;
                document.getElementById('ai-thinking').style.display='none';
                executeMove(move);
            }, 50);
        }

        function calculateBestMove(pid) {
            // Optimization: Depth 2 is safe for JS. Depth 3 is risky without Workers.
            // We use smart heuristics to make Depth 2 feel deeper.
            return minimax(2, -Infinity, Infinity, true, pid).move;
        }

        function minimax(depth, alpha, beta, isMax, pid) {
            const opp = pid===1?2:1;
            
            // Leaf or End
            if(depth === 0) return { val: evaluate(pid) };
            if(state.pos[pid].y === state.pos[pid].goal) return { val: 100000 };
            if(state.pos[opp].y === state.pos[opp].goal) return { val: -100000 };

            let bestMove = null;
            let moves = getCandidates(pid);

            // Sorting: Moves first (better pruning)
            moves.sort((a,b) => (a.type==='move'?-1:1));

            if(isMax) {
                let maxEval = -Infinity;
                for(let m of moves) {
                    if(m.type==='move') { m.prev={x:state.pos[pid].x, y:state.pos[pid].y}; state.pos[pid].x=m.x; state.pos[pid].y=m.y; }
                    else { state.walls[pid]--; state.placedWalls.add(`${m.x},${m.y},${m.orientation}`); }

                    let ev = minimax(depth-1, alpha, beta, false, opp).val; // Switch PID for next level is handled by passing opp

                    // Undo
                    if(m.type==='move') { state.pos[pid].x=m.prev.x; state.pos[pid].y=m.prev.y; }
                    else { state.walls[pid]++; state.placedWalls.delete(`${m.x},${m.y},${m.orientation}`); }

                    if(ev > maxEval) { maxEval = ev; bestMove = m; }
                    alpha = Math.max(alpha, ev);
                    if(beta <= alpha) break;
                }
                // Fallback
                if(!bestMove && moves.length>0) bestMove = moves[0];
                return { val: maxEval, move: bestMove };
            } else {
                // Min node (Opponent) - we want to minimize THEIR score (which is effectively maximizing ours if we flip sign, but here we just minimize)
                // Wait, simplify: Standard Minimax. Max player wants +Infinity, Min player wants -Infinity.
                // My evaluate function returns high score if I am winning.
                // So Min player (opponent) wants to minimize MY evaluation.
                
                let minEval = Infinity;
                for(let m of moves) { // moves for opp
                     if(m.type==='move') { m.prev={x:state.pos[pid].x, y:state.pos[pid].y}; state.pos[pid].x=m.x; state.pos[pid].y=m.y; }
                    else { state.walls[pid]--; state.placedWalls.add(`${m.x},${m.y},${m.orientation}`); }

                    // Here we pass the ORIGINAL MAX PID back to eval function implicitly? 
                    // No, recursing: current is 'pid' (which is opp), next is 'original pid'.
                    // Actually standard minimax usually keeps 'rootPid' constant for evaluation.
                    // Let's refactor slightly for clarity: pass rootPid to eval.
                    
                    // QUICK FIX: Recurse back to original Max player logic
                    // The function signature `minimax` here takes `pid` as the *current mover*.
                    // But evaluate needs to know who is the AI.
                    // Let's stick to: Evaluate always returns (AI Advantage).
                    // So Max player maximizes (AI Advantage). Min player minimizes (AI Advantage).
                    
                    // So we need to call minimax for the *other* player, but keep score relative to AI.
                    // The 'pid' arg in recursive call is the player moving in that node.
                    
                    let ev = minimax(depth-1, alpha, beta, !isMax, opp===1?2:1).val; // wait, pid swap logic is messy.

                    // Undo
                    if(m.type==='move') { state.pos[pid].x=m.prev.x; state.pos[pid].y=m.prev.y; }
                    else { state.walls[pid]++; state.placedWalls.delete(`${m.x},${m.y},${m.orientation}`); }

                    if(ev < minEval) { minEval = ev; bestMove = m; }
                    beta = Math.min(beta, ev);
                    if(beta <= alpha) break;
                }
                 return { val: minEval, move: bestMove };
            }
        }
        
        // Corrected Minimax Wrapper for clarity
        function minimax(depth, alpha, beta, isMaximizingPlayer, currentPid) {
             const aiPid = 2; // AI is always P2 in PvE
             const oppPid = 1;

             // Leaf
             if (depth === 0) return { val: evaluate(aiPid) };
             
             // Check Win/Loss
             if(state.pos[aiPid].y === state.pos[aiPid].goal) return { val: 10000 };
             if(state.pos[oppPid].y === state.pos[oppPid].goal) return { val: -10000 };

             const moves = getCandidates(currentPid);
             moves.sort((a,b) => (a.type==='move'?-1:1)); // Heuristic sort

             if (isMaximizingPlayer) {
                 let maxEval = -Infinity;
                 let bestMove = moves[0] || null;
                 for (let m of moves) {
                     apply(m, currentPid);
                     let ev = minimax(depth - 1, alpha, beta, false, oppPid).val;
                     undo(m, currentPid);
                     if (ev > maxEval) { maxEval = ev; bestMove = m; }
                     alpha = Math.max(alpha, ev);
                     if (beta <= alpha) break;
                 }
                 return { val: maxEval, move: bestMove };
             } else {
                 let minEval = Infinity;
                 let bestMove = moves[0] || null;
                 for (let m of moves) {
                     apply(m, currentPid);
                     let ev = minimax(depth - 1, alpha, beta, true, aiPid).val;
                     undo(m, currentPid);
                     if (ev < minEval) { minEval = ev; bestMove = m; }
                     beta = Math.min(beta, ev);
                     if (beta <= alpha) break;
                 }
                 return { val: minEval, move: bestMove };
             }
        }

        function apply(m, pid) {
             if(m.type==='move') { m.prev={x:state.pos[pid].x, y:state.pos[pid].y}; state.pos[pid].x=m.x; state.pos[pid].y=m.y; }
             else { state.walls[pid]--; state.placedWalls.add(`${m.x},${m.y},${m.orientation}`); }
        }
        function undo(m, pid) {
             if(m.type==='move') { state.pos[pid].x=m.prev.x; state.pos[pid].y=m.prev.y; }
             else { state.walls[pid]++; state.placedWalls.delete(`${m.x},${m.y},${m.orientation}`); }
        }

        function evaluate(pid) {
            const opp = pid===1?2:1;
            const d1 = getShortestPath(pid);
            const d2 = getShortestPath(opp);
            if(d1 === -1) return -10000; // Blocked myself
            if(d2 === -1) return 10000;  // Blocked opponent (Wait, illegal? Minimax shouldn't produce this, but safe to score high)
            
            // Score = (Opponent Dist - My Dist) + Wall Bonus
            // AI wants My Dist small, Opp Dist large.
            return (d2 - d1) * 10 + (state.walls[pid] - state.walls[opp]) * 2 + Math.random(); 
        }

        function getCandidates(pid) {
            const res = [];
            // Moves
            getValidMoves(pid).forEach(m => res.push({type:'move', x:m.x, y:m.y}));
            
            // Walls (Optimization: Only near players)
            if(state.walls[pid] > 0) {
                const range = 1;
                const targets = [state.pos[1], state.pos[2]];
                const checked = new Set();
                targets.forEach(t => {
                    for(let dx=-range; dx<=range; dx++) for(let dy=-range; dy<=range; dy++) {
                        let wx=t.x+dx, wy=t.y+dy;
                        ['h','v'].forEach(o => {
                            if(!checked.has(`${wx},${wy},${o}`) && canPlaceWall(wx,wy,o)) {
                                res.push({type:'wall', x:wx, y:wy, orientation:o});
                                checked.add(`${wx},${wy},${o}`);
                            }
                        });
                    }
                });
            }
            return res;
        }

        // --- Online Logic (PeerJS) ---
        function showOnlineMenu() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('online-menu').style.display = 'flex';
        }

        function cancelOnline() {
            if(state.online.peer) { state.online.peer.destroy(); state.online.peer=null; }
            state.online.conn = null;
            document.getElementById('online-menu').style.display = 'none';
            document.getElementById('start-screen').style.display = 'flex';
            document.getElementById('start-screen').style.opacity = 1;
            document.getElementById('host-ui').style.display = 'none';
            document.getElementById('online-options').style.display = 'block';
        }

        function initPeer() {
            return new Promise((resolve, reject) => {
                const peer = new Peer(null, { debug: 1 }); // Auto generated ID
                peer.on('open', (id) => {
                    state.online.peer = peer;
                    resolve(id);
                });
                peer.on('error', (err) => {
                    showToast("ÈÄ£Á∑öÈåØË™§: " + err.type);
                    reject(err);
                });
            });
        }

        async function hostGame() {
            document.getElementById('online-loading').style.display='block';
            try {
                const id = await initPeer();
                state.online.isHost = true;
                state.online.myPid = 1; // Host is P1
                
                document.getElementById('online-loading').style.display='none';
                document.getElementById('online-options').style.display='none';
                document.getElementById('host-ui').style.display='block';
                document.getElementById('room-id-display').innerText = id;

                state.online.peer.on('connection', (conn) => {
                    setupConnection(conn);
                });
            } catch(e) { console.error(e); }
        }

        async function joinGame() {
            const id = document.getElementById('join-id-input').value.trim();
            if(!id) return showToast("Ë´ãËº∏ÂÖ• ID");
            
            document.getElementById('online-loading').style.display='block';
            try {
                await initPeer(); // Init my peer first
                state.online.isHost = false;
                state.online.myPid = 2; // Joiner is P2
                
                const conn = state.online.peer.connect(id);
                conn.on('open', () => {
                    setupConnection(conn);
                });
                conn.on('error', () => showToast("ÁÑ°Ê≥ïÈÄ£Á∑öÂà∞Ë©≤ ID"));
            } catch(e) { console.error(e); }
        }

        function setupConnection(conn) {
            state.online.conn = conn;
            document.getElementById('online-menu').style.display='none';
            showToast("ÈÄ£Á∑öÊàêÂäüÔºÅÈÅäÊà≤ÈñãÂßã");
            
            startGame('online');

            conn.on('data', (data) => {
                // Receive Move
                if(data.type === 'move') {
                    movePlayer(data.x, data.y);
                } else if(data.type === 'wall') {
                    placeWall(data.x, data.y, data.orientation);
                }
            });

            conn.on('close', () => {
                showToast("Â∞çÊñπÂ∑≤Êñ∑Á∑ö");
                setTimeout(()=>resetGame(true), 2000);
            });
        }

        function copyRoomId() {
            const text = document.getElementById('room-id-display').innerText;
            navigator.clipboard.writeText(text).then(() => showToast("ID Â∑≤Ë§áË£Ω!"));
        }

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg; t.style.opacity = 1;
            setTimeout(()=>t.style.opacity=0, 2000);
        }

        // --- Other Utils ---
        function manualRotate() { 
            state.drag.orientation = state.drag.orientation==='h'?'v':'h'; 
            document.getElementById('rotate-btn').innerText = `ÊóãËΩâ (${state.drag.orientation==='h'?'Ê©´':'Áõ¥'})`; 
        }
        function showValidMoves() {
            objects.highlights.forEach(h=>scene.remove(h)); objects.highlights=[];
            if(state.isAiThinking || (state.gameType!=='pvp' && state.turn!==state.online.myPid && state.gameType!=='pve') || (state.gameType==='pve' && state.turn===2)) return;
            
            getValidMoves(state.turn).forEach(m=>{
                const ms = new THREE.Mesh(new THREE.BoxGeometry(CELL_W*0.9,0.5,CELL_W*0.9), new THREE.MeshBasicMaterial({color:COLORS.highlight, transparent:true, opacity:0.5}));
                const p = getGridPos(m.x, m.y); ms.position.set(p.x, 1.6, p.z); ms.userData={type:'move',x:m.x,y:m.y};
                scene.add(ms); objects.highlights.push(ms);
            });
        }
        function setupEvents() {
            window.addEventListener('mousemove', e=>handleMove(e)); window.addEventListener('touchmove', e=>handleMove(e),{passive:false});
            window.addEventListener('mouseup', handleUp); window.addEventListener('touchend', handleUp);
            window.addEventListener('mousedown', handleClick); window.addEventListener('touchstart', handleClick,{passive:false});
            window.addEventListener('resize', () => {
                const w=window.innerWidth, h=window.innerHeight; renderer.setSize(w,h);
                cameraP1.aspect=(w/2)/h; cameraP1.updateProjectionMatrix();
                cameraP2.aspect=(w/2)/h; cameraP2.updateProjectionMatrix();
            });
        }
        function toggleSettings() {
            state.paused = !state.paused;
            document.getElementById('settings-menu').style.display = state.paused ? 'flex' : 'none';
        }
        function animate() {
            requestAnimationFrame(animate);
            if(!state.paused) {
                for(let id in objects.pawns) objects.pawns[id].mesh.position.lerp(objects.pawns[id].target, 0.2);
                objects.wallGroup.children.forEach(w => { if(w.userData.targetY && w.position.y>w.userData.targetY) w.position.y += (w.userData.targetY - w.position.y)*0.2; });
            }
            const w=window.innerWidth, h=window.innerHeight; renderer.clear();
            renderer.setViewport(0,0,w/2,h); renderer.setScissor(0,0,w/2,h); renderer.render(scene, cameraP1);
            renderer.setViewport(w/2,0,w/2,h); renderer.setScissor(w/2,0,w/2,h); renderer.render(scene, cameraP2);
        }

        window.onload = init;
    </script>
</body>
</html>