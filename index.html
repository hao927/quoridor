<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Quoridor 3D - Online & Local</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #111; user-select: none; touch-action: none; }
        
        /* Screens */
        .screen-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9); z-index: 2000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; transition: opacity 0.5s;
        }
        #start-screen { z-index: 2001; background: url('https://images.unsplash.com/photo-1611195974226-a6a9be9dd763?q=80&w=1925') center/cover; }
        #start-screen::before { content:''; position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:-1; }
        #online-menu, #settings-menu { display: none; background: rgba(0,0,0,0.95); z-index: 2002; }

        h1 { font-size: 50px; margin-bottom: 30px; text-shadow: 0 0 20px rgba(255,255,255,0.3); text-align: center; }
        .menu-btn {
            background: linear-gradient(135deg, #448aff, #1976d2); border: none; color: white;
            padding: 15px 30px; margin: 10px; font-size: 18px; border-radius: 8px; cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3); width: 280px; font-weight: bold; transition: 0.2s;
        }
        .menu-btn:active { transform: scale(0.95); }
        .menu-btn.ai { background: linear-gradient(135deg, #7b1fa2, #4a148c); }
        .menu-btn.online { background: linear-gradient(135deg, #00c853, #00695c); }
        .menu-btn.secondary { background: #444; border: 1px solid #666; }
        .menu-btn.mode-switch { background: linear-gradient(135deg, #ff9800, #f57c00); }

        /* Inputs */
        .input-group { margin: 10px; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        input[type="text"] { padding: 10px; font-size: 18px; border-radius: 5px; border: 1px solid #555; background: #222; color: white; text-align: center; width: 200px; }
        #room-id-display { font-family: monospace; font-size: 24px; color: #00e676; margin: 10px; padding: 10px; border: 1px dashed #555; cursor: pointer; }

        /* HUD */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #status-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(20, 20, 20, 0.85); padding: 10px 30px; border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1); color: #eee; font-size: 18px; font-weight: bold;
            pointer-events: auto; z-index: 101; white-space: nowrap;
        }
        #ai-thinking {
            position: absolute; top: 70px; left: 50%; transform: translateX(-50%);
            background: rgba(123, 31, 162, 0.9); color: white; padding: 5px 15px; border-radius: 20px;
            display: none; z-index: 102; font-size: 14px;
        }
        
        /* Wall Docks */
        .wall-dock-container {
            position: absolute; width: 35%; height: 70px; background: rgba(0,0,0,0.5); border-radius: 16px;
            display: flex; align-items: center; justify-content: center; gap: 6px; padding: 0 15px;
            pointer-events: auto; transition: 0.3s; z-index: 102;
        }
        .wall-dock-container.active { background: rgba(255,255,255,0.1); box-shadow: 0 0 15px rgba(255,255,255,0.1); }
        
        /* Split Mode Positions */
        .mode-split #dock-p1 { bottom: 20px; left: 2%; }
        .mode-split #dock-p2 { bottom: 20px; right: 2%; }
        /* Single Mode Positions */
        .mode-single #dock-p1 { bottom: 20px; left: 50%; transform: translateX(-50%); width: 60%; }
        .mode-single #dock-p2 { top: 20px; left: 50%; transform: translateX(-50%) rotate(180deg); width: 60%; }

        .wall-item { width: 12px; height: 40px; background: #d4a373; border-radius: 3px; cursor: grab; }
        .dock-label { position: absolute; top: -25px; font-size: 14px; color: #aaa; width: 100%; text-align: center; }

        /* Controls */
        #controls-center {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; pointer-events: auto; z-index: 200;
        }
        .mode-single #controls-center { bottom: 50%; flex-direction: column; left: auto; right: 10px; transform: translateY(50%); }
        
        .action-btn { background: #444; color: white; border: 1px solid rgba(255,255,255,0.3); padding: 10px 20px; border-radius: 10px; font-size: 16px; cursor: pointer; }
        #settings-btn { position: absolute; top: 20px; left: 20px; width: 40px; height: 40px; border-radius: 50%; background: #333; color: white; border: none; cursor: pointer; pointer-events: auto; z-index: 150; font-size: 20px; }

        #victory-screen { display: none; z-index: 2003; cursor: pointer; }
        .victory-title { font-size: 60px; font-weight: bold; margin-bottom: 10px; }
        #toast { position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); background: rgba(50,50,50,0.9); color: white; padding: 10px 20px; border-radius: 5px; z-index: 3000; opacity: 0; transition: opacity 0.3s; pointer-events: none; }
        
        /* View divider */
        #view-divider { position: absolute; left: 50%; top: 0; bottom: 0; width: 2px; background: rgba(255,255,255,0.1); z-index: 100; pointer-events: none; }
        .mode-single #view-divider { display: none; }
    </style>
</head>
<body class="mode-split">

    <!-- Start Screen -->
    <div id="start-screen" class="screen-overlay">
        <h1>Quoridor 3D</h1>
        <button class="menu-btn" onclick="startGame('pvp')">üë• Êú¨Âú∞Èõô‰∫∫ (Local)</button>
        <button class="menu-btn ai" onclick="startGame('pve')">ü§ñ ÊåëÊà∞ AI (PvE)</button>
        <button class="menu-btn online" onclick="showOnlineMenu()">üåê Á∑ö‰∏äÂ∞çÊà∞ (Online)</button>
    </div>

    <!-- Online Menu -->
    <div id="online-menu" class="screen-overlay">
        <h1>Á∑ö‰∏äÂ∞çÊà∞</h1>
        <div id="online-loading" style="display:none; color:#00e676">ÈÄ£Á∑ö‰∏≠...</div>
        <div id="online-options">
            <button class="menu-btn online" onclick="hostGame()">üè† Âª∫Á´ãÊàøÈñì (Host)</button>
            <div style="margin:10px; color:#aaa">- OR -</div>
            <div class="input-group">
                <input type="text" id="join-id-input" placeholder="Ëº∏ÂÖ•ÊàøÈñì ID">
                <button class="menu-btn" onclick="joinGame()">üîó Âä†ÂÖ•ÊàøÈñì (Join)</button>
            </div>
        </div>
        <div id="host-ui" style="display:none; text-align:center;">
            <h2>Á≠âÂæÖÂ∞çÊâã...</h2>
            <div id="room-id-display" onclick="copyRoomId()">---</div>
            <div style="font-size:12px; color:#888">(ÈªûÊìä ID Ë§áË£Ω)</div>
            <br><button class="menu-btn secondary" onclick="cancelOnline()">ÂèñÊ∂à</button>
        </div>
        <button class="menu-btn secondary" onclick="cancelOnline()" style="margin-top:20px">ËøîÂõû</button>
    </div>

    <!-- Settings Menu -->
    <div id="settings-menu" class="screen-overlay">
        <h1>ÈÅ∏ÂñÆ</h1>
        <button class="menu-btn mode-switch" onclick="switchViewMode()">ÂàáÊèõË¶ñËßí: <span id="mode-text">ÂàÜÂâ≤ (Split)</span></button>
        <button class="menu-btn" onclick="toggleSettings()">‚ñ∂ ÁπºÁ∫åÈÅäÊà≤</button>
        <button class="menu-btn secondary" onclick="resetGame(true)">‚â° Âõû‰∏ªÁï´Èù¢</button>
    </div>

    <!-- Victory Screen -->
    <div id="victory-screen" class="screen-overlay" onclick="resetGame(true)">
        <div class="victory-title" id="winner-text">P1 Áç≤Âãù!</div>
        <div style="color:#aaa">ÈªûÊìäÂõûÂà∞‰∏ªÁï´Èù¢</div>
    </div>

    <!-- Main UI -->
    <div id="ui-layer">
        <button id="settings-btn" onclick="toggleSettings()">‚öôÔ∏è</button>
        <div id="view-divider"></div>
        <div id="status-bar"><span id="turn-msg">P1 ÂõûÂêà</span></div>
        <div id="ai-thinking">‚ú® AI ÊÄùËÄÉ‰∏≠...</div>

        <div id="controls-center">
            <button id="rotate-btn" class="action-btn" onclick="manualRotate()">ÊóãËΩâÁâÜÂ£Å (Ëá™Âãï)</button>
        </div>

        <div id="dock-p1" class="wall-dock-container"><div class="dock-label">P1 ÁâÜÂ£Å</div></div>
        <div id="dock-p2" class="wall-dock-container"><div class="dock-label">P2 ÁâÜÂ£Å</div></div>
        <div id="toast">Ë®äÊÅØ</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Constants & State ---
        const BOARD_SIZE = 9, CELL_W = 10, GAP_W = 2.5;
        const BOARD_W = BOARD_SIZE * CELL_W + (BOARD_SIZE - 1) * GAP_W;
        const COLORS = { board: 0x3e2723, cell: 0x5d4037, wall: 0xeecc99, p1: 0xd32f2f, p2: 0x1976d2, highlight: 0x4caf50 };

        let state = {
            started: false, paused: false, turn: 1, viewMode: 'split',
            walls: { 1: 10, 2: 10 },
            pos: { 1: {x:4, y:0, goal:8}, 2: {x:4, y:8, goal:0} },
            placedWalls: new Set(),
            gameType: 'pvp', 
            isAiThinking: false,
            online: { isHost: false, myPid: 1, conn: null, peer: null },
            drag: { active: false, orientation: 'h', valid: false, gx: -1, gy: -1, sourceEl: null }
        };

        let scene, renderer, cameraP1, cameraP2, cameraSingle;
        let objects = { pawns: {}, ghostWall: null, highlights: [], wallGroup: null };
        let raycaster, mouse, dragPlane;
        const audio = {
            move: new Audio('https://assets.mixkit.co/active_storage/sfx/2052/2052-preview.mp3'),
            wall: new Audio('https://assets.mixkit.co/active_storage/sfx/2053/2053-preview.mp3'),
            win: new Audio('https://assets.mixkit.co/active_storage/sfx/2069/2069-preview.mp3')
        };

        // --- Init ---
        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x1a1a1a);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setScissorTest(true); renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Cameras
            const aspectSplit = (window.innerWidth/2) / window.innerHeight;
            const aspectFull = window.innerWidth / window.innerHeight;
            cameraP1 = new THREE.PerspectiveCamera(40, aspectSplit, 0.1, 1000);
            cameraP1.position.set(0, 180, -130); cameraP1.lookAt(0,0,10);
            
            cameraP2 = new THREE.PerspectiveCamera(40, aspectSplit, 0.1, 1000);
            cameraP2.position.set(0, 180, 130); cameraP2.lookAt(0,0,-10);

            cameraSingle = new THREE.PerspectiveCamera(45, aspectFull, 0.1, 1000);
            cameraSingle.position.set(0, 280, 0); cameraSingle.lookAt(0,0,0); cameraSingle.rotation.z = Math.PI; // Top-down

            // Scene
            scene.add(new THREE.HemisphereLight(0xffeeb1, 0x080820, 0.5));
            const l = new THREE.DirectionalLight(0xfffaf0, 1.2); l.position.set(30,80,50); l.castShadow=true; 
            l.shadow.mapSize.width=2048; l.shadow.mapSize.height=2048; scene.add(l);
            
            createBoard(); createPawns();
            objects.wallGroup = new THREE.Group(); scene.add(objects.wallGroup);
            createGhostWall();

            raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();
            dragPlane = new THREE.Mesh(new THREE.PlaneGeometry(500,500), new THREE.MeshBasicMaterial({visible:false}));
            dragPlane.rotation.x = -Math.PI/2; dragPlane.position.y = 8; scene.add(dragPlane);

            setupEvents(); animate();
        }

        function createBoard() {
            const g = new THREE.Group();
            const b = new THREE.Mesh(new THREE.BoxGeometry(BOARD_W+6, 2, BOARD_W+6), new THREE.MeshStandardMaterial({color:COLORS.board, roughness:0.8}));
            b.position.y = -1; b.receiveShadow=true; g.add(b);
            const gm = new THREE.BoxGeometry(CELL_W, 1.5, CELL_W);
            const mm = new THREE.MeshStandardMaterial({color:COLORS.cell, roughness:0.5});
            for(let y=0; y<BOARD_SIZE; y++) for(let x=0; x<BOARD_SIZE; x++) {
                const m = new THREE.Mesh(gm,mm); const p = getGridPos(x,y);
                m.position.set(p.x, 0.75, p.z); m.receiveShadow=true; m.castShadow=true; g.add(m);
            }
            scene.add(g);
        }
        function createPawns() {
            [1,2].forEach(id=>{
                const gr = new THREE.Group();
                const m = new THREE.MeshStandardMaterial({color: id===1?COLORS.p1:COLORS.p2});
                gr.add(new THREE.Mesh(new THREE.CylinderGeometry(2.5,3.5,6,32), m));
                gr.add(new THREE.Mesh(new THREE.SphereGeometry(3,32,16), m)).position.y=4;
                gr.traverse(o=>{if(o.isMesh)o.castShadow=true;});
                const p = getGridPos(state.pos[id].x, state.pos[id].y); gr.position.set(p.x,3,p.z);
                objects.pawns[id] = {mesh:gr, target:new THREE.Vector3(p.x,3,p.z)}; scene.add(gr);
            });
        }
        function createGhostWall() {
            objects.ghostWall = new THREE.Mesh(new THREE.BoxGeometry(CELL_W*2+GAP_W, 4, GAP_W*0.9), new THREE.MeshBasicMaterial({color:COLORS.wall, transparent:true, opacity:0.6}));
            objects.ghostWall.visible=false; scene.add(objects.ghostWall);
        }

        // --- Logic ---
        function getGridPos(gx, gy) { return { x: -(BOARD_W/2)+CELL_W/2 + gx*(CELL_W+GAP_W), z: -(BOARD_W/2)+CELL_W/2 + gy*(CELL_W+GAP_W) }; }
        function getWallPos(gx, gy, o) { 
            const s = -(BOARD_W/2)+CELL_W+GAP_W/2, st = CELL_W+GAP_W;
            return { x: s + gx*st, z: s + gy*st, angle: o==='h'?0:Math.PI/2 }; 
        }
        function canStep(x1,y1,x2,y2) {
            if(x2<0||x2>=9||y2<0||y2>=9) return false;
            if(x1===x2){ const r=Math.min(y1,y2); if(state.placedWalls.has(`${x1},${r},h`)||state.placedWalls.has(`${x1-1},${r},h`))return false; }
            else{ const c=Math.min(x1,x2); if(state.placedWalls.has(`${c},${y1},v`)||state.placedWalls.has(`${c},${y1-1},v`))return false; }
            return true;
        }
        function getValidMoves(pid) {
            const m=[]; const p=state.pos[pid]; const opp=state.pos[pid===1?2:1];
            [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}].forEach(d=>{
                const nx=p.x+d.x, ny=p.y+d.y;
                if(canStep(p.x,p.y,nx,ny)){
                    if(nx===opp.x && ny===opp.y){
                        const jx=nx+d.x, jy=ny+d.y;
                        if(canStep(nx,ny,jx,jy)) m.push({x:jx,y:jy});
                        else {
                            if(d.x===0){ if(canStep(nx,ny,nx-1,ny))m.push({x:nx-1,y:ny}); if(canStep(nx,ny,nx+1,ny))m.push({x:nx+1,y:ny}); }
                            else{ if(canStep(nx,ny,nx,ny-1))m.push({x:nx,y:ny-1}); if(canStep(nx,ny,nx,ny+1))m.push({x:nx,y:ny+1}); }
                        }
                    } else m.push({x:nx,y:ny});
                }
            });
            return m;
        }
        function canPlaceWall(x,y,o) {
            if(x<0||x>=8||y<0||y>=8) return false;
            const k=`${x},${y},`; 
            if(state.placedWalls.has(k+'h')||state.placedWalls.has(k+'v')) return false;
            if(o==='h'&&(state.placedWalls.has(`${x-1},${y},h`)||state.placedWalls.has(`${x+1},${y},h`))) return false;
            if(o==='v'&&(state.placedWalls.has(`${x},${y-1},v`)||state.placedWalls.has(`${x},${y+1},v`))) return false;
            state.placedWalls.add(k+o);
            const ok = getShortestPath(1)!==-1 && getShortestPath(2)!==-1;
            state.placedWalls.delete(k+o);
            return ok;
        }
        function getShortestPath(pid) {
            const q=[{x:state.pos[pid].x, y:state.pos[pid].y, d:0}]; const v=new Set([`${q[0].x},${q[0].y}`]); const g=state.pos[pid].goal;
            while(q.length){
                const c=q.shift(); if(c.y===g) return c.d;
                [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}].forEach(d=>{
                    const nx=c.x+d.x, ny=c.y+d.y;
                    if(canStep(c.x,c.y,nx,ny)&&!v.has(`${nx},${ny}`)){ v.add(`${nx},${ny}`); q.push({x:nx,y:ny,d:c.d+1}); }
                });
            } return -1;
        }

        // --- Game Flow ---
        function startGame(type) {
            state.gameType = type; state.started = true;
            document.getElementById('start-screen').style.opacity=0;
            setTimeout(()=>document.getElementById('start-screen').style.display='none', 500);
            
            if(type === 'online' && state.online.myPid === 2) showToast("Â∑≤ÈÄ£Á∑öÔºÅÁ≠âÂæÖ P1 ÁßªÂãï...");
            
            resetBoardVisuals();
            // Default to Single View for Local PvP (easier for phone), Split for Online
            if(type === 'pvp') { 
                state.viewMode = 'single';
                document.getElementById('mode-text').innerText = "ÂÖ®Ëû¢Âπï (Single)";
                document.body.className = 'mode-single';
            }
            updateHUD(); showValidMoves();
        }
        function resetGame(fullReset=false) {
            state.started = false; state.paused = false; state.turn = 1;
            state.walls = {1:10, 2:10};
            state.pos = {1:{x:4,y:0,goal:8}, 2:{x:4,y:8,goal:0}};
            state.placedWalls.clear(); state.isAiThinking = false;

            document.getElementById('victory-screen').style.display='none';
            document.getElementById('settings-menu').style.display='none';
            document.getElementById('ai-thinking').style.display='none';
            document.getElementById('online-menu').style.display='none';

            if(fullReset) {
                if(state.online.peer) { state.online.peer.destroy(); state.online.peer = null; }
                state.online.conn = null;
                document.getElementById('start-screen').style.display='flex';
                document.getElementById('start-screen').style.opacity=1;
            }
            resetBoardVisuals();
        }
        function resetBoardVisuals() {
            while(objects.wallGroup.children.length>0) objects.wallGroup.remove(objects.wallGroup.children[0]);
            [1,2].forEach(id=>{
                const p = getGridPos(state.pos[id].x, state.pos[id].y);
                objects.pawns[id].target.copy(new THREE.Vector3(p.x,3,p.z));
                objects.pawns[id].mesh.position.copy(objects.pawns[id].target);
            });
            renderWallDocks(); updateHUD();
        }
        function switchViewMode() {
            state.viewMode = state.viewMode === 'split' ? 'single' : 'split';
            document.body.className = state.viewMode === 'split' ? 'mode-split' : 'mode-single';
            document.getElementById('mode-text').innerText = state.viewMode === 'split' ? 'ÂàÜÂâ≤ (Split)' : 'ÂÖ®Ëû¢Âπï (Single)';
            // Resize trigger
            const w=window.innerWidth, h=window.innerHeight;
            if(state.viewMode === 'split') {
                cameraP1.aspect = (w/2)/h; cameraP1.updateProjectionMatrix();
                cameraP2.aspect = (w/2)/h; cameraP2.updateProjectionMatrix();
            } else {
                cameraSingle.aspect = w/h; cameraSingle.updateProjectionMatrix();
            }
        }

        // --- Interaction ---
        function getPointerData(e, wd=false) {
            const w=window.innerWidth, h=window.innerHeight;
            let cx, cy, isTouch=false;
            if(e.changedTouches){ cx=e.changedTouches[0].clientX; cy=e.changedTouches[0].clientY; isTouch=true; }
            else { cx=e.clientX; cy=e.clientY; }
            
            if(wd && isTouch) {
                // Adjust touch for wall dock drag
                if(state.viewMode === 'single' && state.turn === 2) cy += 120; // Inverted top dock
                else cy -= 120;
            }
            
            let cam, ndcx, ndcy;
            if(state.viewMode === 'split') {
                if(cx<w/2){ ndcx=(cx/(w/2))*2-1; cam=cameraP1; } else { ndcx=((cx-w/2)/(w/2))*2-1; cam=cameraP2; }
                ndcy = -(cy/h)*2+1;
            } else {
                ndcx = (cx/w)*2-1; ndcy = -(cy/h)*2+1; cam = cameraSingle;
            }
            return { x:ndcx, y:ndcy, camera:cam, rawY:isTouch?cy:e.clientY };
        }

        function handleClick(e) {
            if(!state.started || state.paused || state.isAiThinking || state.drag.active) return;
            // Permission Checks
            if(state.gameType === 'online' && state.turn !== state.online.myPid) return;
            if(state.gameType === 'pve' && state.turn === 2) return;
            
            if(e.target.closest('.wall-dock-container') || e.target.closest('button')) return;

            const ptr = getPointerData(e); if(!ptr.camera) return;
            mouse.set(ptr.x, ptr.y); raycaster.setFromCamera(mouse, ptr.camera);
            
            const hits = raycaster.intersectObjects(objects.highlights);
            if(hits.length>0) {
                const d = hits[0].object.userData;
                executeMove({ type:'move', x:d.x, y:d.y });
            }
        }

        function startWallDrag(e, pid, el) {
            if(!state.started || state.paused || state.turn !== pid) return;
            if(state.gameType === 'online' && state.turn !== state.online.myPid) return;
            if(state.gameType === 'pve' && pid === 2) return;

            e.preventDefault(); e.stopPropagation();
            state.drag.active=true; state.drag.sourceEl=el; el.classList.add('dragging');
            objects.ghostWall.visible=true; handleMove(e);
        }

        function handleMove(e) {
            if(!state.drag.active) return;
            e.preventDefault();
            const ptr = getPointerData(e, true);
            
            // Check dock collision
            const h = window.innerHeight;
            let isOverDock = false;
            if(state.viewMode === 'single') {
                 if(state.turn===1 && ptr.rawY > h-100) isOverDock=true;
                 if(state.turn===2 && ptr.rawY < 100) isOverDock=true;
            } else {
                 if(ptr.rawY > h-100) isOverDock=true;
            }

            if(isOverDock) { objects.ghostWall.visible=false; state.drag.valid=false; return; }
            objects.ghostWall.visible=true;
            
            mouse.set(ptr.x, ptr.y); raycaster.setFromCamera(mouse, ptr.camera);
            const hits = raycaster.intersectObject(dragPlane);
            
            if(hits.length>0) {
                const pt = hits[0].point;
                const st = CELL_W+GAP_W; const s = -(BOARD_W/2)+CELL_W+GAP_W/2;
                let gx = Math.round((pt.x-s)/st), gy = Math.round((pt.z-s)/st);
                
                let dx = Math.abs(((pt.x-s)/st)-gx), dy = Math.abs(((pt.z-s)/st)-gy);
                // Adjust orientation preference based on exact hit
                if(state.drag.orientation==='h') dy-=0.1; else dx-=0.1;
                state.drag.orientation = dx<dy?'v':'h';

                if(gx<0)gx=0; if(gx>7)gx=7; if(gy<0)gy=0; if(gy>7)gy=7;
                
                const valid = canPlaceWall(gx, gy, state.drag.orientation);
                state.drag.gx = gx; state.drag.gy = gy; state.drag.valid = valid;
                
                const p = getWallPos(gx, gy, state.drag.orientation);
                objects.ghostWall.position.set(p.x, 6, p.z);
                objects.ghostWall.rotation.y = p.angle;
                objects.ghostWall.material.color.setHex(valid ? COLORS.wall : 0xff0000);
            }
        }

        function handleUp(e) {
            if(state.drag.active) {
                state.drag.active=false; objects.ghostWall.visible=false;
                if(state.drag.sourceEl) state.drag.sourceEl.classList.remove('dragging');
                if(state.drag.valid) executeMove({ type:'wall', x:state.drag.gx, y:state.drag.gy, orientation:state.drag.orientation });
                state.drag.sourceEl=null;
            }
        }

        // --- Actions ---
        function executeMove(moveData) {
            if(moveData.type === 'move') movePlayer(moveData.x, moveData.y);
            else placeWall(moveData.x, moveData.y, moveData.orientation);

            if(state.gameType === 'online' && state.online.conn && state.online.conn.open && state.turn === state.online.myPid) {
                 state.online.conn.send(moveData);
            }
        }
        function movePlayer(x, y) {
            state.pos[state.turn].x = x; state.pos[state.turn].y = y;
            const p = getGridPos(x,y); objects.pawns[state.turn].target.copy(new THREE.Vector3(p.x,3,p.z));
            audio.move.currentTime=0; audio.move.play().catch(()=>{});
            checkWin(); nextTurn();
        }
        function placeWall(x, y, o) {
            state.walls[state.turn]--; state.placedWalls.add(`${x},${y},${o}`);
            const m = new THREE.Mesh(new THREE.BoxGeometry(CELL_W*2+GAP_W, 3.5, GAP_W*0.95), new THREE.MeshStandardMaterial({color:COLORS.wall}));
            const p = getWallPos(x,y,o); m.position.set(p.x, 10, p.z); m.rotation.y = p.angle;
            m.castShadow=true; m.receiveShadow=true; m.userData={targetY:1.5}; objects.wallGroup.add(m);
            audio.wall.play().catch(()=>{});
            renderWallDocks(); nextTurn();
        }
        function nextTurn() {
            state.turn = state.turn===1 ? 2 : 1; updateHUD();
            if(state.gameType === 'pve' && state.turn === 2) setTimeout(triggerAI, 500); else showValidMoves();
        }
        function checkWin() {
            if(state.pos[state.turn].y === state.pos[state.turn].goal) {
                audio.win.play().catch(()=>{});
                document.getElementById('winner-text').innerText = state.turn===1 ? 'P1 Áç≤Âãù!' : 'P2 Áç≤Âãù!';
                document.getElementById('winner-text').style.color = state.turn===1 ? '#ff5252' : '#448aff';
                document.getElementById('victory-screen').style.display='flex';
                state.paused = true;
            }
        }
        function updateHUD() {
            const t = document.getElementById('turn-msg');
            let txt = `P${state.turn} ÂõûÂêà`;
            if(state.gameType === 'online') txt += (state.turn === state.online.myPid) ? " (‰Ω†)" : " (Â∞çÊâã)";
            t.innerText = txt; t.style.color = state.turn===1 ? '#ff5252' : '#448aff';
            document.getElementById('dock-p1').classList.toggle('active', state.turn===1);
            document.getElementById('dock-p2').classList.toggle('active', state.turn===2);
        }
        function renderWallDocks() {
            const d1=document.getElementById('dock-p1'); const d2=document.getElementById('dock-p2');
            d1.innerHTML='<div class="dock-label">P1 ÁâÜÂ£Å</div>'; d2.innerHTML='<div class="dock-label">P2 ÁâÜÂ£Å</div>';
            for(let i=0;i<state.walls[1];i++){ let w=document.createElement('div'); w.className='wall-item'; w.onmousedown=e=>startWallDrag(e,1,w); w.ontouchstart=e=>startWallDrag(e,1,w); d1.appendChild(w); }
            for(let i=0;i<state.walls[2];i++){ let w=document.createElement('div'); w.className='wall-item'; w.style.backgroundColor='#448aff'; w.onmousedown=e=>startWallDrag(e,2,w); w.ontouchstart=e=>startWallDrag(e,2,w); d2.appendChild(w); }
        }
        function manualRotate() { 
            state.drag.orientation = state.drag.orientation==='h'?'v':'h'; 
            document.getElementById('rotate-btn').innerText = `ÊóãËΩâÁâÜÂ£Å (${state.drag.orientation==='h'?'Ê©´':'Áõ¥'})`; 
        }
        function showValidMoves() {
            objects.highlights.forEach(h=>scene.remove(h)); objects.highlights=[];
            if(state.isAiThinking || (state.gameType!=='pvp' && state.turn!==state.online.myPid && state.gameType!=='pve') || (state.gameType==='pve' && state.turn===2)) return;
            getValidMoves(state.turn).forEach(m=>{
                const ms = new THREE.Mesh(new THREE.BoxGeometry(CELL_W*0.9,0.5,CELL_W*0.9), new THREE.MeshBasicMaterial({color:COLORS.highlight, transparent:true, opacity:0.5}));
                const p = getGridPos(m.x, m.y); ms.position.set(p.x, 1.6, p.z); ms.userData={type:'move',x:m.x,y:m.y};
                scene.add(ms); objects.highlights.push(ms);
            });
        }
        function showToast(msg) {
            const t = document.getElementById('toast'); t.innerText = msg; t.style.opacity = 1;
            setTimeout(()=>t.style.opacity=0, 2000);
        }

        // --- AI (Safe) ---
        function triggerAI() {
            state.isAiThinking = true; document.getElementById('ai-thinking').style.display='block';
            objects.highlights.forEach(h=>scene.remove(h)); objects.highlights=[];
            
            setTimeout(() => {
                let move = null;
                try {
                    move = runMinimax();
                } catch (e) { console.error("AI Error:", e); }
                
                // Fallback if AI fails or returns null
                if(!move) { const m = getValidMoves(2); move = {type:'move', x:m[0].x, y:m[0].y}; }

                state.isAiThinking = false; document.getElementById('ai-thinking').style.display='none';
                executeMove(move);
            }, 50);
        }

        function runMinimax() {
            // Root call for AI (P2)
            const rootMoves = getCandidates(2);
            rootMoves.sort((a,b) => (a.type==='move'?-1:1));
            
            let bestVal = -Infinity; let bestMove = null;
            
            for(let m of rootMoves) {
                apply(m, 2);
                let val = minimaxRec(1, -Infinity, Infinity, false, 1); // Depth 1, next is P1 (Min)
                undo(m, 2);
                if(val > bestVal) { bestVal = val; bestMove = m; }
            }
            return bestMove;
        }

        function minimaxRec(depth, alpha, beta, isMax, pid) {
            const opp = pid===1?2:1;
            // Eval
            if(depth === 0) return evaluate(2); // Always eval for AI (P2) perspective
            
            // Win Check in recursion (Simplified)
            if(state.pos[2].y === 0) return 10000;
            if(state.pos[1].y === 8) return -10000;

            const moves = getCandidates(pid);
            if(moves.length === 0) return isMax ? -10000 : 10000; // Stuck

            if(isMax) {
                let maxEval = -Infinity;
                for(let m of moves) {
                    apply(m, pid);
                    let ev = minimaxRec(depth-1, alpha, beta, false, opp);
                    undo(m, pid);
                    maxEval = Math.max(maxEval, ev); alpha = Math.max(alpha, ev);
                    if(beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for(let m of moves) {
                    apply(m, pid);
                    let ev = minimaxRec(depth-1, alpha, beta, true, opp);
                    undo(m, pid);
                    minEval = Math.min(minEval, ev); beta = Math.min(beta, ev);
                    if(beta <= alpha) break;
                }
                return minEval;
            }
        }

        function evaluate(aiPid) {
            const oppPid = aiPid===1?2:1;
            const dAI = getShortestPath(aiPid); const dOpp = getShortestPath(oppPid);
            if(dAI === -1) return -20000; // AI Blocked
            if(dOpp === -1) return 20000; // Opponent Blocked (Illegal but good for scoring)
            // AI wants to Minimize dAI and Maximize dOpp
            return (dOpp - dAI) * 10 + (state.walls[aiPid] - state.walls[oppPid]) * 2 + Math.random();
        }

        function getCandidates(pid) {
            const res = [];
            getValidMoves(pid).forEach(m => res.push({type:'move', x:m.x, y:m.y}));
            if(state.walls[pid] > 0) {
                const range = 1; // Optimization
                const targets = [state.pos[1], state.pos[2]];
                const checked = new Set();
                targets.forEach(t => {
                    for(let dx=-range; dx<=range; dx++) for(let dy=-range; dy<=range; dy++) {
                        let wx=t.x+dx, wy=t.y+dy;
                        ['h','v'].forEach(o => {
                            if(!checked.has(`${wx},${wy},${o}`) && canPlaceWall(wx,wy,o)) {
                                res.push({type:'wall', x:wx, y:wy, orientation:o});
                                checked.add(`${wx},${wy},${o}`);
                            }
                        });
                    }
                });
            }
            return res;
        }

        function apply(m, pid) {
             if(m.type==='move') { m.prev={x:state.pos[pid].x, y:state.pos[pid].y}; state.pos[pid].x=m.x; state.pos[pid].y=m.y; }
             else { state.walls[pid]--; state.placedWalls.add(`${m.x},${m.y},${m.orientation}`); }
        }
        function undo(m, pid) {
             if(m.type==='move') { state.pos[pid].x=m.prev.x; state.pos[pid].y=m.prev.y; }
             else { state.walls[pid]++; state.placedWalls.delete(`${m.x},${m.y},${m.orientation}`); }
        }

        // --- Setup ---
        function setupEvents() {
            window.addEventListener('mousemove', e=>handleMove(e)); window.addEventListener('touchmove', e=>handleMove(e),{passive:false});
            window.addEventListener('mouseup', handleUp); window.addEventListener('touchend', handleUp);
            window.addEventListener('mousedown', handleClick); window.addEventListener('touchstart', handleClick,{passive:false});
            window.addEventListener('resize', () => {
                const w=window.innerWidth, h=window.innerHeight; renderer.setSize(w,h);
                if(state.viewMode === 'split') {
                    cameraP1.aspect=(w/2)/h; cameraP1.updateProjectionMatrix();
                    cameraP2.aspect=(w/2)/h; cameraP2.updateProjectionMatrix();
                } else {
                    cameraSingle.aspect=w/h; cameraSingle.updateProjectionMatrix();
                }
            });
        }
        function toggleSettings() { state.paused = !state.paused; document.getElementById('settings-menu').style.display = state.paused ? 'flex' : 'none'; }
        
        function animate() {
            requestAnimationFrame(animate);
            if(!state.paused) {
                for(let id in objects.pawns) objects.pawns[id].mesh.position.lerp(objects.pawns[id].target, 0.2);
                objects.wallGroup.children.forEach(w => { if(w.userData.targetY && w.position.y>w.userData.targetY) w.position.y += (w.userData.targetY - w.position.y)*0.2; });
            }
            const w=window.innerWidth, h=window.innerHeight; renderer.clear();
            if(state.viewMode === 'split') {
                renderer.setViewport(0,0,w/2,h); renderer.setScissor(0,0,w/2,h); renderer.render(scene, cameraP1);
                renderer.setViewport(w/2,0,w/2,h); renderer.setScissor(w/2,0,w/2,h); renderer.render(scene, cameraP2);
            } else {
                renderer.setViewport(0,0,w,h); renderer.setScissor(0,0,w,h); renderer.render(scene, cameraSingle);
            }
        }
        
        // --- Online PeerJS ---
        function showOnlineMenu() { document.getElementById('start-screen').style.display='none'; document.getElementById('online-menu').style.display='flex'; }
        function cancelOnline() { 
            if(state.online.peer){ state.online.peer.destroy(); state.online.peer=null;} state.online.conn=null;
            document.getElementById('online-menu').style.display='none'; document.getElementById('start-screen').style.display='flex';
            document.getElementById('start-screen').style.opacity=1; document.getElementById('host-ui').style.display='none'; document.getElementById('online-options').style.display='block';
        }
        function initPeer() {
            return new Promise((resolve, reject) => {
                const peer = new Peer(null);
                peer.on('open', id => { state.online.peer=peer; resolve(id); });
                peer.on('error', err => { showToast("ÈÄ£Á∑öÈåØË™§"); reject(err); });
            });
        }
        async function hostGame() {
            document.getElementById('online-loading').style.display='block';
            try {
                const id = await initPeer();
                state.online.isHost=true; state.online.myPid=1;
                document.getElementById('online-loading').style.display='none'; document.getElementById('online-options').style.display='none';
                document.getElementById('host-ui').style.display='block'; document.getElementById('room-id-display').innerText=id;
                state.online.peer.on('connection', conn => setupConnection(conn));
            } catch(e) { console.error(e); }
        }
        async function joinGame() {
            const id = document.getElementById('join-id-input').value.trim(); if(!id) return showToast("Ë´ãËº∏ÂÖ• ID");
            document.getElementById('online-loading').style.display='block';
            try {
                await initPeer();
                state.online.isHost=false; state.online.myPid=2;
                const conn = state.online.peer.connect(id);
                conn.on('open', () => setupConnection(conn));
                conn.on('error', () => showToast("ÁÑ°Ê≥ïÈÄ£Á∑ö"));
            } catch(e) { console.error(e); }
        }
        function setupConnection(conn) {
            state.online.conn = conn; document.getElementById('online-menu').style.display='none';
            // Start game in Split Mode for Online
            state.viewMode = 'split'; document.body.className = 'mode-split';
            startGame('online');
            conn.on('data', data => { if(data.type==='move') movePlayer(data.x, data.y); else placeWall(data.x, data.y, data.orientation); });
            conn.on('close', () => { showToast("Â∞çÊñπÊñ∑Á∑ö"); setTimeout(()=>resetGame(true), 2000); });
        }
        function copyRoomId() { navigator.clipboard.writeText(document.getElementById('room-id-display').innerText).then(()=>showToast("Â∑≤Ë§áË£Ω ID")); }

        window.onload = init;
    </script>
</body>
</html>
