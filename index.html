<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Quoridor 3D - Online Lobby</title>
    
    <!-- Firebase Libraries -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>

    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #111; user-select: none; touch-action: none; color: white; }
        
        /* --- Screens --- */
        .screen-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9); z-index: 2000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.5s;
        }
        #start-screen { z-index: 2001; background: url('https://images.unsplash.com/photo-1611195974226-a6a9be9dd763?q=80&w=1925') center/cover; }
        #start-screen::before { content:''; position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:-1; }
        
        /* Lobby Styles */
        #lobby-screen { display: none; z-index: 2002; background: #1a1a1a; justify-content: flex-start; padding-top: 50px; }
        .lobby-container { width: 90%; max-width: 600px; height: 70%; display: flex; flex-direction: column; gap: 15px; }
        
        .room-list { 
            flex: 1; background: #222; border: 1px solid #444; border-radius: 8px; 
            overflow-y: auto; padding: 10px; box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }
        .room-item {
            display: flex; justify-content: space-between; align-items: center;
            background: #333; margin-bottom: 8px; padding: 15px; border-radius: 6px; cursor: pointer; transition: 0.2s;
            border-left: 5px solid #448aff;
        }
        .room-item:hover { background: #444; transform: translateX(5px); }
        .room-item.private { border-left-color: #ff5252; }
        .room-info { display: flex; flex-direction: column; }
        .room-name { font-size: 18px; font-weight: bold; }
        .room-status { font-size: 12px; color: #aaa; }
        .lock-icon { font-size: 20px; }

        /* Modals */
        .modal { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.8); display: none; justify-content: center; align-items: center; z-index: 3000;
        }
        .modal-content { 
            background: #2a2a2a; padding: 30px; border-radius: 12px; width: 300px; 
            box-shadow: 0 10px 25px rgba(0,0,0,0.5); border: 1px solid #444;
        }
        
        h1 { font-size: 40px; margin-bottom: 20px; text-shadow: 0 0 20px rgba(255,255,255,0.3); text-align: center; }
        h3 { margin-top: 0; }

        .menu-btn {
            background: linear-gradient(135deg, #448aff, #1976d2); border: none; color: white;
            padding: 15px 30px; margin: 10px; font-size: 18px; border-radius: 8px; cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3); width: 280px; font-weight: bold; transition: 0.2s;
            text-align: center;
        }
        .menu-btn:active { transform: scale(0.95); }
        .menu-btn.create { background: linear-gradient(135deg, #00c853, #00695c); width: 100%; margin: 0; }
        .menu-btn.cancel { background: #444; border: 1px solid #666; width: 100%; margin: 10px 0 0 0; }

        /* Inputs */
        input[type="text"], input[type="password"], input[type="number"] {
            width: 100%; padding: 12px; margin: 8px 0; box-sizing: border-box;
            background: #111; border: 1px solid #555; color: white; border-radius: 6px; font-size: 16px;
        }
        .checkbox-group { display: flex; align-items: center; gap: 10px; margin: 10px 0; }

        /* Game UI */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #status-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(20, 20, 20, 0.85); padding: 10px 30px; border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1); font-size: 18px; font-weight: bold; pointer-events: auto;
        }
        
        .wall-dock-container {
            position: absolute; width: 40%; height: 70px; background: rgba(0,0,0,0.5); border-radius: 16px;
            display: flex; align-items: center; justify-content: center; gap: 6px; padding: 0 15px;
            pointer-events: auto; transition: 0.3s; z-index: 102;
            bottom: 20px; left: 50%; transform: translateX(-50%);
        }
        .wall-dock-container.inactive { opacity: 0.3; pointer-events: none; }
        .wall-item { width: 12px; height: 40px; background: #d4a373; border-radius: 3px; cursor: grab; }
        
        /* Opponent Dock (Top, smaller) */
        #dock-opp {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            width: 30%; height: 40px; background: rgba(0,0,0,0.3); border-radius: 10px;
            display: flex; align-items: center; justify-content: center; gap: 4px; opacity: 0.6;
        }
        #dock-opp .wall-item { width: 8px; height: 25px; background: #448aff; cursor: default; }

        #controls-center {
            position: absolute; bottom: 100px; right: 20px;
            display: flex; flex-direction: column; gap: 15px; pointer-events: auto;
        }
        .action-btn { background: #444; color: white; border: 1px solid rgba(255,255,255,0.3); padding: 12px; border-radius: 50%; width: 50px; height: 50px; font-size: 20px; cursor: pointer; display: flex; justify-content: center; align-items: center;}
        
        #victory-screen { display: none; z-index: 2003; cursor: pointer; }
        .victory-title { font-size: 60px; font-weight: bold; margin-bottom: 10px; }
        #toast { position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%); background: rgba(50,50,50,0.95); padding: 10px 20px; border-radius: 5px; z-index: 3000; opacity: 0; transition: opacity 0.3s; pointer-events: none; }

        /* Setup Overlay */
        #firebase-setup { 
            position: absolute; top:0; left:0; width:100%; height:100%; background:#111; z-index: 5000; 
            display:flex; flex-direction:column; align-items:center; justify-content:center; padding: 20px; box-sizing: border-box; text-align: center;
        }
        .config-box { width: 80%; height: 200px; background: #222; color: #0f0; font-family: monospace; border: 1px solid #555; padding: 10px; }
    </style>
</head>
<body class="mode-single">

    <!-- Firebase Config Warning -->
    <div id="firebase-setup">
        <h2>âš ï¸ éœ€è¦ Firebase è¨­å®š</h2>
        <p>è«‹å°‡ Firebase æ§åˆ¶å°ä¸­çš„ config ä»£ç¢¼è²¼åœ¨ä¸‹æ–¹ã€‚</p>
        <p style="font-size:14px; color:#aaa;">æ”¯æ´ç›´æ¥è²¼ä¸Š const firebaseConfig = { ... }; æ•´æ®µä»£ç¢¼</p>
        <textarea id="firebase-config-input" class="config-box" placeholder='const firebaseConfig = { ... }'></textarea>
        <button class="menu-btn" onclick="saveConfig()">å„²å­˜ä¸¦é–‹å§‹</button>
        <p style="font-size: 12px; color: #888; margin-top: 10px;">è³‡æ–™åƒ…å„²å­˜åœ¨ç€è¦½å™¨ LocalStorageï¼Œä¸æœƒå¤–æ´©ã€‚</p>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="screen-overlay">
        <h1>Quoridor 3D</h1>
        <button class="menu-btn" onclick="startGame('pvp')">ğŸ‘¥ æœ¬åœ°é›™äºº (Local)</button>
        <button class="menu-btn ai" onclick="startGame('pve')">ğŸ¤– æŒ‘æˆ° AI (PvE)</button>
        <button class="menu-btn online" onclick="openLobby()">ğŸŒ ç·šä¸Šå¤§å»³ (Lobby)</button>
    </div>

    <!-- Lobby Screen -->
    <div id="lobby-screen" class="screen-overlay">
        <h1>ç·šä¸ŠéŠæˆ²å¤§å»³</h1>
        <div class="lobby-container">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <span id="player-id-display" style="color:#aaa; font-size:14px;">ID: ...</span>
                <button onclick="showCreateRoom()" style="background:#00c853; border:none; padding:8px 16px; border-radius:4px; color:white; cursor:pointer;">+ å»ºç«‹æˆ¿é–“</button>
            </div>
            
            <div class="room-list" id="room-list">
                <div style="text-align:center; color:#666; padding:20px;">è¼‰å…¥ä¸­...</div>
            </div>
            
            <button class="menu-btn cancel" onclick="closeLobby()">è¿”å›ä¸»é¸å–®</button>
        </div>
    </div>

    <!-- Create Room Modal -->
    <div id="create-modal" class="modal">
        <div class="modal-content">
            <h3>å»ºç«‹æ–°æˆ¿é–“</h3>
            <input type="text" id="new-room-name" placeholder="æˆ¿é–“åç¨± (ä¾‹: æ–°æ‰‹æˆ¿)" maxlength="10">
            <div class="checkbox-group">
                <input type="checkbox" id="is-private" onchange="togglePasswordInput()">
                <label for="is-private">è¨­å®šç§äººå¯†ç¢¼ (6ä½æ•¸)</label>
            </div>
            <input type="number" id="room-password" placeholder="è¼¸å…¥ 6 ä½æ•¸å¯†ç¢¼" style="display:none;" oninput="if(this.value.length>6) this.value=this.value.slice(0,6);">
            
            <button class="menu-btn create" onclick="createRoom()">å»ºç«‹</button>
            <button class="menu-btn cancel" onclick="document.getElementById('create-modal').style.display='none'">å–æ¶ˆ</button>
        </div>
    </div>

    <!-- Join Password Modal -->
    <div id="password-modal" class="modal">
        <div class="modal-content">
            <h3>ğŸ”’ è¼¸å…¥æˆ¿é–“å¯†ç¢¼</h3>
            <p id="join-room-name" style="color:#aaa; margin-bottom:10px;"></p>
            <input type="number" id="join-password" placeholder="6 ä½æ•¸å¯†ç¢¼">
            <button class="menu-btn create" onclick="submitPassword()">åŠ å…¥</button>
            <button class="menu-btn cancel" onclick="closePasswordModal()">å–æ¶ˆ</button>
        </div>
    </div>

    <!-- Waiting Modal -->
    <div id="waiting-modal" class="modal">
        <div class="modal-content" style="text-align:center;">
            <h3>ç­‰å¾…å°æ‰‹åŠ å…¥...</h3>
            <div class="loader" style="margin:20px 0; font-size:24px;">â³</div>
            <p>æˆ¿è™Ÿ: <span id="wait-room-id" style="color:#00e676; font-family:monospace;"></span></p>
            <button class="menu-btn cancel" onclick="leaveRoom()">å–æ¶ˆ/é›¢é–‹</button>
        </div>
    </div>

    <!-- Victory Screen -->
    <div id="victory-screen" class="screen-overlay" onclick="resetGame(true)">
        <div class="victory-title" id="winner-text">ç²å‹!</div>
        <div style="color:#aaa">é»æ“Šé›¢é–‹</div>
    </div>

    <!-- Main Game UI -->
    <div id="ui-layer">
        <div id="status-bar"><span id="turn-msg">P1 å›åˆ</span></div>
        
        <div id="controls-center">
            <button id="rotate-btn" class="action-btn" onclick="manualRotate()">â†»</button>
            <button id="exit-btn" class="action-btn" style="background:#d32f2f;" onclick="confirmExit()">Ã—</button>
        </div>

        <!-- My Dock -->
        <div id="dock-my" class="wall-dock-container">
            <!-- Walls injected here -->
        </div>

        <!-- Opponent Walls Count -->
        <div id="dock-opp">
            <span style="color:white; font-size:12px; margin-right:5px;">å°æ‰‹ç‰†å£:</span>
            <div id="opp-walls-viz" style="display:flex; gap:2px;"></div>
        </div>

        <div id="toast">è¨Šæ¯</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- 1. Firebase Logic (Fixed Parsing) ---
        let db, auth, currentUser;
        let unsubscribeRooms = null;
        let unsubscribeGame = null;
        let currentRoomId = null;

        function initFirebase() {
            const savedConfig = localStorage.getItem('quoridor_firebase_config');
            if (savedConfig) {
                try {
                    const config = JSON.parse(savedConfig);
                    firebase.initializeApp(config);
                    db = firebase.firestore();
                    auth = firebase.auth();
                    
                    auth.signInAnonymously().then(userCred => {
                        currentUser = userCred.user;
                        document.getElementById('firebase-setup').style.display = 'none';
                        document.getElementById('player-id-display').innerText = `ID: ${currentUser.uid.substring(0,6)}`;
                    }).catch(e => {
                        alert("Firebase é€£ç·šå¤±æ•—ï¼Œè«‹æª¢æŸ¥ Config");
                        document.getElementById('firebase-setup').style.display = 'flex';
                    });
                } catch (e) {
                    console.error(e);
                    document.getElementById('firebase-setup').style.display = 'flex';
                }
            } else {
                document.getElementById('firebase-setup').style.display = 'flex';
            }
        }

        // IMPROVED PARSING LOGIC
        function saveConfig() {
            let val = document.getElementById('firebase-config-input').value.trim();
            if(!val) return alert("è«‹è¼¸å…¥å…§å®¹");

            // Attempt to extract object from "const firebaseConfig = { ... };"
            if(val.includes("firebaseConfig")) {
                const match = val.match(/firebaseConfig\s*=\s*({[\s\S]*?});?/);
                if(match) val = match[1];
            }

            try {
                // Use Function to parse JS Object notation (keys without quotes) safely
                // This allows pasting directly from Firebase console without editing
                const config = (new Function("return " + val))();
                
                if(!config.apiKey || !config.projectId) throw new Error("ç¼ºå°‘å¿…è¦æ¬„ä½");

                localStorage.setItem('quoridor_firebase_config', JSON.stringify(config));
                initFirebase();
            } catch(e) { 
                console.error(e);
                alert("æ ¼å¼éŒ¯èª¤ï¼šè«‹ç¢ºä¿æ‚¨è¤‡è£½çš„æ˜¯ { ... } å…§çš„å…§å®¹ï¼Œæˆ–è€…ç›´æ¥è¤‡è£½æ•´æ®µ const firebaseConfig = ... ä»£ç¢¼"); 
            }
        }

        function openLobby() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('lobby-screen').style.display = 'flex';
            
            // Listen to rooms
            unsubscribeRooms = db.collection('rooms')
                .where('status', '==', 'waiting')
                .onSnapshot(snapshot => {
                    const list = document.getElementById('room-list');
                    list.innerHTML = '';
                    if(snapshot.empty) {
                        list.innerHTML = '<div style="text-align:center; padding:20px; color:#666">ç›®å‰æ²’æœ‰æˆ¿é–“</div>';
                        return;
                    }
                    snapshot.forEach(doc => {
                        const r = doc.data();
                        const div = document.createElement('div');
                        div.className = `room-item ${r.isPrivate ? 'private' : ''}`;
                        div.innerHTML = `
                            <div class="room-info">
                                <span class="room-name">${r.name}</span>
                                <span class="room-status">Host: ${r.hostName || 'Unknown'}</span>
                            </div>
                            ${r.isPrivate ? '<span class="lock-icon">ğŸ”’</span>' : '<span style="color:#00e676">åŠ å…¥</span>'}
                        `;
                        div.onclick = () => tryJoinRoom(doc.id, r);
                        list.appendChild(div);
                    });
                });
        }

        function closeLobby() {
            if(unsubscribeRooms) unsubscribeRooms();
            document.getElementById('lobby-screen').style.display = 'none';
            document.getElementById('start-screen').style.display = 'flex';
        }

        // --- Room Management ---
        function showCreateRoom() { document.getElementById('create-modal').style.display = 'flex'; }
        
        function togglePasswordInput() {
            const checked = document.getElementById('is-private').checked;
            document.getElementById('room-password').style.display = checked ? 'block' : 'none';
        }

        async function createRoom() {
            const name = document.getElementById('new-room-name').value || "æœªå‘½åæˆ¿é–“";
            const isPrivate = document.getElementById('is-private').checked;
            const password = document.getElementById('room-password').value;

            if(isPrivate && (!password || password.length !== 6)) return alert("è«‹è¨­å®š 6 ä½æ•¸å¯†ç¢¼");

            const roomData = {
                name: name,
                isPrivate: isPrivate,
                password: isPrivate ? password : null,
                hostId: currentUser.uid,
                hostName: "Player " + currentUser.uid.substring(0,4),
                status: 'waiting',
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                players: { p1: currentUser.uid }
            };

            try {
                const docRef = await db.collection('rooms').add(roomData);
                currentRoomId = docRef.id;
                state.online.myPid = 1; // Host is P1
                document.getElementById('create-modal').style.display = 'none';
                waitForOpponent(currentRoomId);
            } catch(e) { console.error(e); alert("å»ºç«‹å¤±æ•—"); }
        }

        function waitForOpponent(roomId) {
            document.getElementById('wait-room-id').innerText = roomId.substring(0,6);
            document.getElementById('waiting-modal').style.display = 'flex';
            
            unsubscribeGame = db.collection('rooms').doc(roomId).onSnapshot(doc => {
                if(!doc.exists) return leaveRoom();
                const data = doc.data();
                if(data.players.p2) {
                    // Game Start!
                    document.getElementById('waiting-modal').style.display = 'none';
                    document.getElementById('lobby-screen').style.display = 'none';
                    startGame('online');
                }
            });
        }

        let pendingJoinId = null;
        function tryJoinRoom(roomId, roomData) {
            if(roomData.isPrivate) {
                pendingJoinId = roomId;
                document.getElementById('join-room-name').innerText = roomData.name;
                document.getElementById('password-modal').style.display = 'flex';
                document.getElementById('join-password').value = '';
            } else {
                doJoin(roomId);
            }
        }

        function submitPassword() {
            const input = document.getElementById('join-password').value;
            // Client side verify for simplicity in this demo. Real app should use Cloud Functions.
            db.collection('rooms').doc(pendingJoinId).get().then(doc => {
                if(doc.data().password == input) {
                    doJoin(pendingJoinId);
                    closePasswordModal();
                } else {
                    alert("å¯†ç¢¼éŒ¯èª¤");
                }
            });
        }
        function closePasswordModal() { document.getElementById('password-modal').style.display = 'none'; pendingJoinId = null; }

        async function doJoin(roomId) {
            try {
                await db.collection('rooms').doc(roomId).update({
                    "players.p2": currentUser.uid,
                    status: 'playing',
                    gameState: {
                        turn: 1, // P1 starts
                        pos: { 1:{x:4,y:0}, 2:{x:4,y:8} },
                        walls: { 1:10, 2:10 },
                        lastAction: null
                    }
                });
                currentRoomId = roomId;
                state.online.myPid = 2; // Joiner is P2
                document.getElementById('lobby-screen').style.display = 'none';
                startGame('online');
                listenToGame(roomId);
            } catch(e) { alert("ç„¡æ³•åŠ å…¥ (å¯èƒ½å·²æ»¿)"); }
        }

        function listenToGame(roomId) {
            unsubscribeGame = db.collection('rooms').doc(roomId).onSnapshot(doc => {
                if(!doc.exists) { alert("æˆ¿é–“å·²è§£æ•£"); resetGame(true); return; }
                const data = doc.data();
                const gs = data.gameState;
                if(!gs) return; // Wait for host init

                // Sync State
                if(gs.lastAction && gs.lastAction.by !== state.online.myPid) {
                    // Only apply moves made by opponent
                    applyRemoteAction(gs.lastAction);
                }
            });
        }

        function leaveRoom() {
            if(currentRoomId) {
                if(state.online.myPid === 1) db.collection('rooms').doc(currentRoomId).delete(); // Host deletes
                else db.collection('rooms').doc(currentRoomId).update({ "players.p2": firebase.firestore.FieldValue.delete(), status:'waiting' });
            }
            resetGame(true);
        }

        function confirmExit() {
            if(confirm("ç¢ºå®šè¦é›¢é–‹æˆ¿é–“å—ï¼Ÿ")) leaveRoom();
        }

        function syncMove(action) {
            if(!currentRoomId) return;
            // Optimistic update locally first (already done by game logic), then send
            db.collection('rooms').doc(currentRoomId).update({
                "gameState.lastAction": { ...action, by: state.online.myPid, ts: Date.now() }
            });
        }


        // --- 2. Game Logic (Three.js) ---
        const BOARD_SIZE = 9, CELL_W = 10, GAP_W = 2.5;
        const BOARD_W = BOARD_SIZE * CELL_W + (BOARD_SIZE - 1) * GAP_W;
        const COLORS = { board: 0x222, cell: 0x333, wall: 0xeecc99, p1: 0xd32f2f, p2: 0x1976d2, highlight: 0x4caf50 };

        let state = {
            started: false, turn: 1, 
            walls: { 1: 10, 2: 10 },
            pos: { 1: {x:4, y:0, goal:8}, 2: {x:4, y:8, goal:0} },
            placedWalls: new Set(),
            gameType: 'pvp',
            online: { myPid: 1 },
            drag: { active: false, orientation: 'h', valid: false, gx: -1, gy: -1 }
        };

        let scene, renderer, camera;
        let objects = { pawns: {}, ghostWall: null, highlights: [], wallGroup: null };
        let raycaster, mouse, dragPlane;
        
        function initThree() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x111);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Lights
            scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));
            const l = new THREE.DirectionalLight(0xffffff, 0.8); l.position.set(20, 50, 20); l.castShadow=true; scene.add(l);

            createBoard(); createPawns();
            objects.wallGroup = new THREE.Group(); scene.add(objects.wallGroup);
            createGhostWall();

            raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();
            dragPlane = new THREE.Mesh(new THREE.PlaneGeometry(500,500), new THREE.MeshBasicMaterial({visible:false}));
            dragPlane.rotation.x = -Math.PI/2; dragPlane.position.y = 8; scene.add(dragPlane);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            setupEvents(); animate();
        }

        // ... (Standard Create Board/Pawn functions simplified for brevity but same logic) ...
        function createBoard() {
            const g = new THREE.Group();
            const b = new THREE.Mesh(new THREE.BoxGeometry(BOARD_W+6, 2, BOARD_W+6), new THREE.MeshStandardMaterial({color:COLORS.board}));
            b.position.y = -1; b.receiveShadow=true; g.add(b);
            const gm = new THREE.BoxGeometry(CELL_W, 1.5, CELL_W);
            const mm = new THREE.MeshStandardMaterial({color:COLORS.cell});
            for(let y=0; y<BOARD_SIZE; y++) for(let x=0; x<BOARD_SIZE; x++) {
                const m = new THREE.Mesh(gm,mm); const p = getGridPos(x,y);
                m.position.set(p.x, 0.75, p.z); m.receiveShadow=true; g.add(m);
            }
            scene.add(g);
        }
        function createPawns() {
            [1,2].forEach(id=>{
                const m = new THREE.MeshStandardMaterial({color: id===1?COLORS.p1:COLORS.p2});
                const mesh = new THREE.Mesh(new THREE.CylinderGeometry(3,3,6,32), m);
                const p = getGridPos(state.pos[id].x, state.pos[id].y); mesh.position.set(p.x,3,p.z); mesh.castShadow=true;
                objects.pawns[id] = {mesh:mesh, target:new THREE.Vector3(p.x,3,p.z)}; scene.add(mesh);
            });
        }
        function createGhostWall() {
            objects.ghostWall = new THREE.Mesh(new THREE.BoxGeometry(CELL_W*2+GAP_W, 4, GAP_W*0.9), new THREE.MeshBasicMaterial({color:COLORS.wall, transparent:true, opacity:0.6}));
            objects.ghostWall.visible=false; scene.add(objects.ghostWall);
        }

        // --- View Logic (Crucial for Online) ---
        function updateCamera() {
            // Default P1 View
            let x=0, y=160, z=-130;
            let lookZ=10;

            if (state.gameType === 'online' && state.online.myPid === 2) {
                // P2 View: Rotate 180
                z = 130; lookZ = -10;
            } else if (state.gameType === 'pvp' && state.turn === 2) {
                // Local PvP dynamic rotation (optional, sticking to fixed for now)
            }

            camera.position.set(x, y, z);
            camera.lookAt(0, 0, lookZ);
        }

        // --- Core Game Logic ---
        function getGridPos(gx, gy) { return { x: -(BOARD_W/2)+CELL_W/2 + gx*(CELL_W+GAP_W), z: -(BOARD_W/2)+CELL_W/2 + gy*(CELL_W+GAP_W) }; }
        function getWallPos(gx, gy, o) { 
            const s = -(BOARD_W/2)+CELL_W+GAP_W/2, st = CELL_W+GAP_W;
            return { x: s + gx*st, z: s + gy*st, angle: o==='h'?0:Math.PI/2 }; 
        }

        function startGame(type) {
            state.gameType = type; state.started = true; state.turn = 1;
            
            if(type === 'online') {
                document.getElementById('start-screen').style.display='none';
                if(state.online.myPid === 1) listenToGame(currentRoomId); // Host listens too
            } else {
                state.online.myPid = 1; // Default View
                document.getElementById('start-screen').style.display='none';
            }
            
            resetVisuals();
            updateCamera();
            updateHUD();
            if(state.gameType === 'pve' && state.turn === 2) triggerAI();
            else showValidMoves();
        }

        function resetGame(full) {
            state.started = false; 
            state.walls = {1:10, 2:10};
            state.pos = {1:{x:4,y:0,goal:8}, 2:{x:4,y:8,goal:0}};
            state.placedWalls.clear();
            
            if(unsubscribeGame) { unsubscribeGame(); unsubscribeGame=null; }
            if(full) {
                document.getElementById('victory-screen').style.display = 'none';
                document.getElementById('start-screen').style.display = 'flex';
                document.getElementById('waiting-modal').style.display = 'none';
                document.getElementById('create-modal').style.display = 'none';
                document.getElementById('password-modal').style.display = 'none';
                document.getElementById('lobby-screen').style.display = 'none';
                currentRoomId = null;
            }
            resetVisuals();
        }

        function resetVisuals() {
            while(objects.wallGroup.children.length>0) objects.wallGroup.remove(objects.wallGroup.children[0]);
            [1,2].forEach(id=>{
                const p = getGridPos(state.pos[id].x, state.pos[id].y);
                objects.pawns[id].target.copy(new THREE.Vector3(p.x,3,p.z));
                objects.pawns[id].mesh.position.copy(objects.pawns[id].target);
            });
        }

        function applyRemoteAction(act) {
            if(act.type === 'move') {
                state.pos[act.by].x = act.x; state.pos[act.by].y = act.y;
                const p = getGridPos(act.x, act.y);
                objects.pawns[act.by].target.copy(new THREE.Vector3(p.x,3,p.z));
            } else {
                state.walls[act.by]--;
                state.placedWalls.add(`${act.x},${act.y},${act.orientation}`);
                const m = new THREE.Mesh(new THREE.BoxGeometry(CELL_W*2+GAP_W, 3.5, GAP_W*0.95), new THREE.MeshStandardMaterial({color:COLORS.wall}));
                const p = getWallPos(act.x, act.y, act.orientation);
                m.position.set(p.x, 10, p.z); m.rotation.y = p.angle;
                m.userData={targetY:1.5}; objects.wallGroup.add(m);
            }
            
            checkWin(act.by);
            state.turn = act.by === 1 ? 2 : 1;
            updateHUD();
            showValidMoves();
        }

        function executeLocalAction(act) {
            // Check permission
            if(state.gameType === 'online' && state.turn !== state.online.myPid) return;
            if(state.gameType === 'pve' && state.turn === 2) return;

            // Apply Locally
            if(act.type === 'move') {
                state.pos[state.turn].x = act.x; state.pos[state.turn].y = act.y;
                const p = getGridPos(act.x, act.y);
                objects.pawns[state.turn].target.copy(new THREE.Vector3(p.x,3,p.z));
            } else {
                state.walls[state.turn]--;
                state.placedWalls.add(`${act.x},${act.y},${act.orientation}`);
                const m = new THREE.Mesh(new THREE.BoxGeometry(CELL_W*2+GAP_W, 3.5, GAP_W*0.95), new THREE.MeshStandardMaterial({color:COLORS.wall}));
                const p = getWallPos(act.x, act.y, act.orientation);
                m.position.set(p.x, 10, p.z); m.rotation.y = p.angle;
                m.userData={targetY:1.5}; objects.wallGroup.add(m);
            }

            // Sync Online
            if(state.gameType === 'online') syncMove({ ...act, by: state.turn });

            checkWin(state.turn);
            state.turn = state.turn === 1 ? 2 : 1;
            updateHUD();

            if(state.gameType === 'pve' && state.turn === 2) setTimeout(triggerAI, 500);
            else showValidMoves();
        }

        // --- UI Updates ---
        function updateHUD() {
            const isMyTurn = state.turn === state.online.myPid;
            const msg = document.getElementById('turn-msg');
            
            if(state.gameType === 'online') {
                msg.innerText = isMyTurn ? "ä½ çš„å›åˆ" : "å°æ‰‹æ€è€ƒä¸­...";
                msg.style.color = isMyTurn ? '#00e676' : '#aaa';
                document.getElementById('dock-my').classList.toggle('inactive', !isMyTurn);
            } else {
                msg.innerText = state.turn === 1 ? "P1 (ç´…) å›åˆ" : "P2 (è—) å›åˆ";
                document.getElementById('dock-my').classList.remove('inactive');
            }

            // Render My Dock
            const myWalls = state.walls[state.online.myPid]; // For Local P1 is default
            const d = document.getElementById('dock-my');
            d.innerHTML = '';
            // If local PVP, show current player's walls. If Online, show MINE.
            const showPid = (state.gameType==='online') ? state.online.myPid : state.turn;
            const count = state.walls[showPid];
            
            for(let i=0; i<count; i++) {
                const w = document.createElement('div'); w.className = 'wall-item';
                w.onmousedown = (e) => startDrag(e, showPid, w);
                w.ontouchstart = (e) => startDrag(e, showPid, w);
                d.appendChild(w);
            }

            // Opponent Dock Viz
            const oppPid = showPid === 1 ? 2 : 1;
            const oppCount = state.walls[oppPid];
            const od = document.getElementById('opp-walls-viz');
            od.innerHTML = '';
            for(let i=0; i<oppCount; i++) {
                const w = document.createElement('div'); w.className = 'wall-item';
                od.appendChild(w);
            }
        }

        // --- Interaction Handlers (Simplified for brevity) ---
        // Includes Logic for canStep, canPlaceWall, getShortestPath (Same as fixed version)
        function canStep(x1,y1,x2,y2) {
            if(x2<0||x2>8||y2<0||y2>8) return false;
            if(x1===x2){ const r=Math.min(y1,y2); if(state.placedWalls.has(`${x1},${r},h`)||state.placedWalls.has(`${x1-1},${r},h`))return false; }
            else{ const c=Math.min(x1,x2); if(state.placedWalls.has(`${c},${y1},v`)||state.placedWalls.has(`${c},${y1-1},v`))return false; }
            return true;
        }
        function canPlaceWall(x,y,o) {
            if(x<0||x>7||y<0||y>7)return false;
            const k=`${x},${y},`; if(state.placedWalls.has(k+'h')||state.placedWalls.has(k+'v')) return false;
            if(o==='h'&&(state.placedWalls.has(`${x-1},${y},h`)||state.placedWalls.has(`${x+1},${y},h`))) return false;
            if(o==='v'&&(state.placedWalls.has(`${x},${y-1},v`)||state.placedWalls.has(`${x},${y+1},v`))) return false;
            state.placedWalls.add(k+o);
            const ok = getPath(1)!==-1 && getPath(2)!==-1;
            state.placedWalls.delete(k+o); return ok;
        }
        function getPath(pid) {
            const q=[{x:state.pos[pid].x,y:state.pos[pid].y,d:0}], v=new Set();
            const g=state.pos[pid].goal;
            while(q.length){
                const c=q.shift(); if(c.y===g)return c.d;
                [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}].forEach(d=>{
                    const nx=c.x+d.x,ny=c.y+d.y;
                    if(canStep(c.x,c.y,nx,ny)&&!v.has(`${nx},${ny}`)){ v.add(`${nx},${ny}`); q.push({x:nx,y:ny,d:c.d+1}); }
                });
            } return -1;
        }
        function getValidMoves(pid) {
            const moves=[]; const p=state.pos[pid]; const opp=state.pos[pid===1?2:1];
            [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}].forEach(d=>{
                const nx=p.x+d.x, ny=p.y+d.y;
                if(canStep(p.x,p.y,nx,ny)) {
                    if(nx===opp.x && ny===opp.y) {
                        // Jump logic
                        const jx=nx+d.x, jy=ny+d.y;
                        if(canStep(nx,ny,jx,jy)) moves.push({x:jx,y:jy});
                        else {
                            if(d.x===0){ if(canStep(nx,ny,nx-1,ny))moves.push({x:nx-1,y:ny}); if(canStep(nx,ny,nx+1,ny))moves.push({x:nx+1,y:ny}); }
                            else{ if(canStep(nx,ny,nx,ny-1))moves.push({x:nx,y:ny-1}); if(canStep(nx,ny,nx,ny+1))moves.push({x:nx,y:ny+1}); }
                        }
                    } else moves.push({x:nx,y:ny});
                }
            });
            return moves;
        }

        // --- Inputs ---
        function getPtr(e) {
            const t = e.touches ? e.touches[0] : e;
            // Map pointer to normalized device coordinates
            // Since we have a single full-screen camera now, it's simpler
            return { 
                x: (t.clientX / window.innerWidth) * 2 - 1, 
                y: -(t.clientY / window.innerHeight) * 2 + 1,
                rawY: t.clientY
            };
        }

        function onClick(e) {
            if(!state.started || state.drag.active) return;
            const ptr = getPtr(e);
            mouse.set(ptr.x, ptr.y); raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(objects.highlights);
            if(hits.length>0) executeLocalAction({ type:'move', ...hits[0].object.userData });
        }

        function startDrag(e, pid, el) {
            if(!state.started || state.gameType==='online' && state.turn!==state.online.myPid) return;
            if(state.gameType==='pvp' && state.turn!==pid) return;

            e.preventDefault();
            state.drag.active=true; objects.ghostWall.visible=true;
            handleDrag(e);
        }

        function handleDrag(e) {
            if(!state.drag.active) return;
            e.preventDefault();
            const ptr = getPtr(e);
            
            // Check Dock Area (Cancel drag if dropped back in dock)
            if(ptr.rawY > window.innerHeight - 80) { objects.ghostWall.visible=false; state.drag.valid=false; return; }
            objects.ghostWall.visible=true;

            mouse.set(ptr.x, ptr.y); raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObject(dragPlane);
            if(hits.length>0) {
                const pt = hits[0].point;
                const st = CELL_W+GAP_W; const s = -(BOARD_W/2)+CELL_W+GAP_W/2;
                let gx = Math.round((pt.x-s)/st), gy = Math.round((pt.z-s)/st);
                
                // Adjust orientation logic based on camera view
                // If P2 view (rotated), the logic for dx/dy might feel inverted relative to mouse movement
                let dx = Math.abs(((pt.x-s)/st)-gx), dy = Math.abs(((pt.z-s)/st)-gy);
                
                if(state.drag.orientation==='h') dy-=0.1; else dx-=0.1;
                state.drag.orientation = dx<dy?'v':'h';

                if(gx<0)gx=0; if(gx>7)gx=7; if(gy<0)gy=0; if(gy>7)gy=7;
                
                const valid = canPlaceWall(gx, gy, state.drag.orientation);
                state.drag.gx = gx; state.drag.gy = gy; state.drag.valid = valid;

                const p = getWallPos(gx, gy, state.drag.orientation);
                objects.ghostWall.position.set(p.x, 6, p.z);
                objects.ghostWall.rotation.y = p.angle;
                objects.ghostWall.material.color.setHex(valid ? COLORS.wall : 0xff0000);
            }
        }

        function endDrag() {
            if(state.drag.active) {
                state.drag.active=false; objects.ghostWall.visible=false;
                if(state.drag.valid) executeLocalAction({ type:'wall', x:state.drag.gx, y:state.drag.gy, orientation:state.drag.orientation });
            }
        }

        function manualRotate() {
            state.drag.orientation = state.drag.orientation==='h'?'v':'h';
            document.getElementById('rotate-btn').innerText = state.drag.orientation==='h'?'â”€':'â”‚';
        }

        function showValidMoves() {
            objects.highlights.forEach(h=>scene.remove(h)); objects.highlights=[];
            // Only show moves if it's my turn
            if(state.gameType === 'online' && state.turn !== state.online.myPid) return;
            
            getValidMoves(state.turn).forEach(m => {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(CELL_W*0.9, 0.5, CELL_W*0.9), new THREE.MeshBasicMaterial({color:COLORS.highlight, transparent:true, opacity:0.5}));
                const p = getGridPos(m.x, m.y); mesh.position.set(p.x, 1.6, p.z);
                mesh.userData = {x:m.x, y:m.y};
                scene.add(mesh); objects.highlights.push(mesh);
            });
        }

        function checkWin(pid) {
            if(state.pos[pid].y === state.pos[pid].goal) {
                document.getElementById('winner-text').innerText = (pid===1?"ç´…æ–¹":"è—æ–¹") + " ç²å‹!";
                document.getElementById('victory-screen').style.display='flex';
                state.started = false;
            }
        }
        
        // --- AI (Simple PVE) ---
        function triggerAI() {
            // Very basic random/greedy AI for offline testing
            setTimeout(() => {
                const moves = getValidMoves(2);
                // Prefer forward
                moves.sort((a,b) => b.y - a.y);
                const m = moves[0];
                if(m) executeLocalAction({type:'move', x:m.x, y:m.y});
            }, 500);
        }

        function setupEvents() {
            window.addEventListener('mousemove', handleDrag); window.addEventListener('touchmove', handleDrag, {passive:false});
            window.addEventListener('mouseup', endDrag); window.addEventListener('touchend', endDrag);
            window.addEventListener('mousedown', onClick); window.addEventListener('touchstart', onClick, {passive:false});
        }

        function animate() {
            requestAnimationFrame(animate);
            for(let id in objects.pawns) objects.pawns[id].mesh.position.lerp(objects.pawns[id].target, 0.2);
            objects.wallGroup.children.forEach(w => { 
                if(w.userData.targetY && w.position.y>w.userData.targetY) w.position.y += (w.userData.targetY - w.position.y)*0.2; 
            });
            renderer.render(scene, camera);
        }

        // Init
        initThree();
        initFirebase(); // Try auto-login

    </script>
</body>
</html>
